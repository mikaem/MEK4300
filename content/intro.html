

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MEK4300 Lecture notes</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS_CHTML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"TeX": {"Macros": {"bmat": ["\\left[\\begin{array}"], "emat": ["\\end{array}\\right]"]}, "extensions": ["cancel.js", "AMSmath.js"]}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe,.cell"
        const thebe_selector_input = "pre,.cell_input div.highlight"
        const thebe_selector_output = ".output,.cell_output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-2 bd-sidebar site-navigation show" id="site-navigation">
    
</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
</div>
        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/mikaem/MEK4300"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        
        
    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/mikaem/MEK4300/master?urlpath=tree/content/intro.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        <button type="button" class="btn btn-secondary topbarbtn"
            onclick="initThebeSBT()" title="Launch Thebe" data-toggle="tooltip" data-placement="left"><i
                class="fas fa-play"></i><span style="margin-left: .4em;">Live Code</span></button>
        
    </div>
</div>

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> On this page
        </div>
        <nav id="bd-toc-nav">
            
        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">Â¶</a></h1>
<p>These lecture notes are created using <a class="reference external" href="https://jupyter.org">Jupyter notebooks</a>. The notes contain
live code examples that can be modified and run. The idea is for the user to get an interactive
experience that hopefully will make the education both more interesting, as well as better quality.
Learning by doing, programming is understanding. The notes are best read with html online. However, they can still be downloaded as a single pdf from the PDF button on the right.</p>
<div class="margin sidebar">
<p class="sidebar-title"></p>
<p><a href="https://github.com/mikaem/MEK4300/blob/master/mek4300.pdf"><button><img  src="../_static/images/Cloud.svg" alt="Get PDF" /> PDF </button></a></p>
</div>
<p>On all html pages in these notes there are some buttons in the top right corner. The last button lets you download the page you are currently surfing as a jupyter notebook or a pdf. The notebook can then be opened, modified and run locally, if you are in an environment with jupyter installed. However, the different pages in these lecture notes are connected, with some links going from one page to another. So you probably want to open all these notebooks in a folder where they all live together. To this end you can for example clone the github repository (third link above) where these notes are stored. The notebooks can then be run if you have a proper environment.
However, if you do not have a proper jupyter environment, then there is also first button, which looks like a rocket. The rockets first link will take you to <a class="reference external" href="https://mybinder.org">Binder</a>, where you will have all notebooks available in te same good environment. This means, in particular,
that the environment will have FEniCS installed for you.</p>
<p>Please note that if you read these notes in jupyter, then some equations and figures will look weird, or unrendered, still in their source, or latex form. This is because all equations in need of reference (especially across different pages) must be written in <a class="reference external" href="https://jupyterbook.org/content/math.html#numbering-equations">MyST Markdown</a> format. This gives nice equations and references in html and pdf, but the notebooks unfortunately look unrendered. It is not wrong, it is just that jupyter still does not know how to render MyST Markdown.</p>
<p>So what about these live computational cells? On most pages of these notes there are computational cell, where code can be typed and executed, like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Hello world!&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Hello world!
</pre></div>
</div>
</div>
</div>
<p>or this</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
</div>
</div>
<p>If you are reading this in jupyter, then these are simply regular code cells. However, on the web (if this is an html) the cells appear first to be dead, and you will be unable to edit them, which is a drag:-( Luckily, at this point you can turn again to the rocket button and press <code class="docutils literal notranslate"><span class="pre">Live</span> <span class="pre">Code</span></code>. This will in turn load a Binder environment that makes it possible to run the cell interactively, while still remaining in the html-version of this book, without moving to Binder. Please note that the first time a binder image is requested for a new version of this book, it may take some time to build and the <em>Waiting for kernelâ¦</em> message seems to be hanging. However, after loading the first time, subsequent runs on this and other pages should be much faster.</p>
<p>Finally, note that <code class="docutils literal notranslate"><span class="pre">dolfin</span></code> is a C++ module of <span class="xref myst">FEniCS</span> that has been wrapped and made callable from Python. In these lecture notes we will make extensive use of FEniCS as a tool for solving the various partial differential equations that arise. FEniCS makes use of the finite element method (FEM), and some knowledge about FEM is an advantage, yet no requirement, when reading these notes.</p>
<div class="toctree-wrapper compound">
<span id="document-content/chapter3/intro"></span><div class="section" id="chapter-3">
<h2>Chapter 3<a class="headerlink" href="#chapter-3" title="Permalink to this headline">Â¶</a></h2>
<p>Chapter 3 in <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a> considers simple solutions of incompressible laminar shear flows. Incompressible flows are described by the physical laws for conservation of mass Newtonâs second law of motion). Together these are usually termed the <em>Navier-Stokes</em> equations that mathematically can be represented as</p>
<div class="math notranslate nohighlight" id="equation-eq-ns">
<span class="eqno">(1)<a class="headerlink" href="#equation-eq-ns" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
  \frac{\partial \boldsymbol{u}}{\partial t} + (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} &amp;= -\frac{1}{\rho} \nabla p + \nu \nabla ^2 \boldsymbol{u} + \boldsymbol{f}  \\ 
  \nabla \cdot \boldsymbol{u} &amp;= 0,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span>, <span class="math notranslate nohighlight">\(p\)</span>, <span class="math notranslate nohighlight">\(\rho\)</span>, <span class="math notranslate nohighlight">\(\nu\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{f}\)</span> are the velocity vector, pressure, density, kinematic viscosity
and body forces respectively. The equations as written are independent of coordinate system, but they look
exactly the same using Cartesian coordinates. Of equally great importance, at least in chapter 3, are the
Navier-Stokes equations in cylindrical coordinates. The cylindrical coordinates, <span class="math notranslate nohighlight">\(r, \theta, z\)</span>, are given in
terms of the Cartesian coordinates <span class="math notranslate nohighlight">\(x, y, z\)</span> as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  x &amp;= r \cos \theta, \\
  y &amp;= r \sin \theta, \\
  z &amp;= z .
\end{aligned}\end{split}\]</div>
<p>The Cartesian position vector is thus</p>
<div class="math notranslate nohighlight">
\[ \boldsymbol{x} = r \cos \theta \boldsymbol{i} + r \sin \theta \boldsymbol{j} + z \boldsymbol{k}.\]</div>
<p>The unit vectors in cylindrical coordinates are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \boldsymbol{i}_{r} &amp;= \frac{\frac{\partial \boldsymbol{x}}{\partial r}}{|\frac{\partial \boldsymbol{x}}{\partial r}|} = \cos \theta \boldsymbol{i} + \sin \theta \boldsymbol{j}, \\
 \boldsymbol{i}_{\theta} &amp;= \frac{\frac{\partial \boldsymbol{x}}{\partial \theta}}{|\frac{\partial \boldsymbol{x}}{\partial \theta}|} = -\sin \theta \boldsymbol{i} + \cos \theta \boldsymbol{j}, \\
 \boldsymbol{i}_{z} &amp;= \frac{\frac{\partial \boldsymbol{x}}{\partial z}}{|\frac{\partial  \boldsymbol{x}}{\partial z}|} = \boldsymbol{k}.
\end{aligned}\end{split}\]</div>
<p>The velocity vectors in Cartesian and cylindrical coordinates read respectively</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \boldsymbol{u}(x,y,z,t) &amp;= u_x \boldsymbol{i} + u_y \boldsymbol{j} + u_z \boldsymbol{k} \\
  \boldsymbol{u}(r,\theta,z,t) &amp;= u_{r} \boldsymbol{i}_r + u_{\theta} \boldsymbol{i}_{\theta} + u_z \boldsymbol{i}_z
\end{aligned}\end{split}\]</div>
<p>The divergence of the velocity vector <span class="math notranslate nohighlight">\(\nabla \cdot \boldsymbol{u}\)</span> in Cartesian and cylindrical coordinates are given respectively by</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \nabla \cdot \boldsymbol{u} &amp;= \frac{\partial u_x}{\partial x} + \frac{\partial u_y}{\partial y} + \frac{\partial u_z}{\partial z} \\
  \nabla \cdot \boldsymbol{u} &amp;= \frac{1}{r}\frac{\partial r u_r}{\partial r} + \frac{1}{r}\frac{\partial u_{\theta}}{\partial \theta} + \frac{\partial u_z}{\partial z}
\end{aligned}\end{split}\]</div>
<p>The Laplacian in Cartesian and cylindrical coordinates are given, respectively, as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \nabla^2 &amp;= \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2} \\
 \nabla^2 &amp;= \frac{1}{r}\frac{\partial}{\partial r}\left( r\frac{\partial}{\partial r} \right) + \frac{1}{r^2}\frac{\partial^2}{\partial \theta ^2} + \frac{\partial^2}{\partial z^2}
\end{aligned}\end{split}\]</div>
<p>The advection <span class="math notranslate nohighlight">\((\boldsymbol{u} \cdot \nabla)\)</span> is given in Cartesian and cylindrical coordinates, respectively, as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\boldsymbol{u} \cdot \nabla  &amp;= u_i \frac{\partial }{\partial x_i}  \\
\boldsymbol{u} \cdot \nabla  &amp;= u_r\frac{\partial}{\partial r} + \frac{1}{r}u_{\theta}\frac{\partial}{\partial \theta} + u_z \frac{\partial}{\partial z}
\end{aligned}\end{split}\]</div>
<p>See <a class="reference external" href="https://mikaem.github.io/mek2200/">mek2200 notes on notation</a> for a more thorough discussion about notation.</p>
<p><font size=5> Suggested assignment Navier-Stokes </font></p>
<p>Start from Navier-Stokes and derive the momentum equations for Cylindrical coordinates. The results are given in App B of <a class="bibtex reference internal" href="content/intro.html#white06" id="id2">[Whi06]</a>.</p>
<p id="bibtex-bibliography-content/chapter3/intro-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets">Whi06</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>)</span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
<div class="toctree-wrapper compound">
<span id="document-content/chapter3/planeshearflow"></span><div class="section" id="parallel-shear-flows">
<h3>Parallel shear flows<a class="headerlink" href="#parallel-shear-flows" title="Permalink to this headline">Â¶</a></h3>
<p>The Navier-Stokes equations are nonlinear because of the convective term, <span class="math notranslate nohighlight">\((\boldsymbol{u} \cdot \nabla)\boldsymbol{u}\)</span>, and in general not analytically solvable for most problems in fluid mechanics. The equations can be solved analytically when the convective term is zero and for a few other simplified flows. In chapter 3 of White we start by considering the types of flow where convection is zero.</p>
<p>The convection term is never negligible for turbulent flows, where the flow rapidly changes direction in a seemingly chaotic fashion. We will get back to turbulent flows in Chapter 6. For now we assume the flow is laminar. For a laminar flow the convection term will be zero for a parallel shear flow where the geometry is infinite in at least one direction and the velocity vector is parallel to the walls of the geometry. For example, a pipe flow or a plane channel flow as shown below</p>
<div class="figure align-default" id="channelprofile">
<a class="reference internal image-reference" href="../_images/channelprofile3.png"><img alt="../_images/channelprofile3.png" src="../_images/channelprofile3.png" style="width: 300px; height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 1 </span><span class="caption-text">Channel flow</span><a class="headerlink" href="#channelprofile" title="Permalink to this image">Â¶</a></p>
</div>
<p>where there is only one nonzero component of the velocity vector, and the velocity vector is parallel to the surrounding walls. The gradient of this velocity component is normal to the wall and as such <span class="math notranslate nohighlight">\(\boldsymbol{u} \cdot \nabla u = 0\)</span> and the Navier-Stokes equations reduce to the linear equations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial \boldsymbol{u}}{\partial t} &amp;= -\frac{1}{\rho} \nabla p + \nu \nabla ^2 \boldsymbol{u} + \boldsymbol{f}, \\
  \nabla \cdot \boldsymbol{u} &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>Since the equations are linear it should not be surprising to find that there are many analytical solutions available for laminar parallel shear flows.</p>
<p>If the only nonzero velocity component is in the x-direction, then <span class="math notranslate nohighlight">\(\boldsymbol{u}=(u, 0, 0)\)</span> and the Navier-Stokes equations reduce to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial u}{\partial t} &amp;= -\frac{1}{\rho} \frac{\partial p}{\partial x} + \nu \nabla ^2 u + f_x, \\
  \frac{\partial u}{\partial x} &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>which is also valid for the axial component of cylindrical coordinates (see Ch. 3-2.2). There are two types of parallel shear flows: Couette and Poiseuille. Couette flows are driven by moving walls. Friction, i.e., drag or viscous forces are then responsible for âdraggingâ the fluid with a direction aligned with the wall. For Poiseuille flows the driving force is a pressure gradient that can be generated using a pump.</p>
<div class="toctree-wrapper compound">
<span id="document-content/chapter3/couette"></span><div class="section" id="couette-flows">
<h4>Couette flows<a class="headerlink" href="#couette-flows" title="Permalink to this headline">Â¶</a></h4>
<p>We will first look at a steady plane Couette flow, like in Chapter 3-2.1, where the height of the plane channel is <span class="math notranslate nohighlight">\(2h\)</span>. There is no applied pressure and no gravitational forces in the <span class="math notranslate nohighlight">\(x\)</span>-direction, so the Navier-Stokes equations reduce further to</p>
<div class="math notranslate nohighlight" id="equation-eq-couettepde">
<span class="eqno">(2)<a class="headerlink" href="#equation-eq-couettepde" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
  \nabla ^2 u &amp;= 0,    \\
  \frac{\partial u}{\partial x} &amp;= 0,
\end{aligned}\end{split}\]</div>
<p>with boundary conditions <span class="math notranslate nohighlight">\(u(-h)=0\)</span> and <span class="math notranslate nohighlight">\(u(h)=U\)</span> (see Fig. 3-1 in <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>). The exact solution of these equations is</p>
<div class="math notranslate nohighlight" id="equation-eq-exactcouette">
<span class="eqno">(3)<a class="headerlink" href="#equation-eq-exactcouette" title="Permalink to this equation">Â¶</a></span>\[ u(y) = \frac{U}{2}\left( 1 + \frac{y}{h} \right).\]</div>
<p>We will now solve the Couette flow numerically using <a class="reference external" href="http://fenicsproject.org">FEniCS</a>, which is a software used for solving differential equations with the finite element method. There is an excellent <a class="reference external" href="http://fenicsproject.org/documentation/tutorial">tutorial</a> for quickly getting started with FEniCS.</p>
<p>FEniCS solves PDEs by expressing the original problem (the PDEs with boundary and initial conditions) as a variational problem. The core of the recipe for turning a PDE into a variational problem is to multiply the PDE by a function <span class="math notranslate nohighlight">\(v\)</span>, integrate the resulting equation over the computational domain (typically called <span class="math notranslate nohighlight">\(\Omega\)</span>), and perform integration by parts of terms with second-order derivatives. The function <span class="math notranslate nohighlight">\(v\)</span> which multiplies the PDE is in the mathematical finite element literature called a test function. The unknown function <span class="math notranslate nohighlight">\(u\)</span> to be approximated is referred to as a trial function. The terms test and trial function are used in FEniCS programs too.</p>
<p>In this course we will learn how to use the FEniCS software, but the focus will be on the physics of flow. We will use FEniCS to generate numerical solutions that we can easily play with to enhance our understanding of what the mathematical equations represent, but we will not go through the inner details of the finite element method.</p>
<p>In the current case of a Couette flow we will solve <a class="reference internal" href="#equation-eq-couettepde">(2)</a>. We assume here for completeness that the equation has an additional constant source <span class="math notranslate nohighlight">\(f\)</span></p>
<div class="math notranslate nohighlight">
\[
\nabla ^2 u = f.
\]</div>
<p>We now multiply the Poisson equation by the test function <span class="math notranslate nohighlight">\(v\)</span> and integrate over the domain <span class="math notranslate nohighlight">\(\Omega=[-h, h]\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\int_\Omega (\nabla^2 u)v \, \mathrm{d}x = \int_\Omega fv \, \mathrm{d}x\thinspace .
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(\mathrm{d}x\)</span> is used to represent a volume integral. For Cartesian coordinates <span class="math notranslate nohighlight">\(\mathrm{d}x\)</span> is equal to <span class="math notranslate nohighlight">\(\mathrm{d}x\mathrm{d}y\mathrm{d}z\)</span>, whereas for cylindrical coordinates it equals <span class="math notranslate nohighlight">\(r\mathrm{d}r\mathrm{d}\theta\mathrm{d}z\)</span>.</p>
<p>Next we apply integration by parts to the integrand on the left hand side with a second-order derivative,</p>
<div class="math notranslate nohighlight" id="equation-eq-secondorderint">
<span class="eqno">(4)<a class="headerlink" href="#equation-eq-secondorderint" title="Permalink to this equation">Â¶</a></span>\[\int_\Omega (\nabla^2 u)v \, \mathrm{d}x =  -\int_\Omega\nabla u\cdot\nabla v \, \mathrm{d}x + \int_{\partial\Omega}{\partial u\over \partial n}v \, \mathrm{d}s ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\partial u \over \partial n\)</span> is the derivative of u in the outward normal direction at the boundary (here at <span class="math notranslate nohighlight">\(y=\pm h\)</span>). The test function <span class="math notranslate nohighlight">\(v\)</span> is required to vanish on the parts of the boundary where <span class="math notranslate nohighlight">\(u\)</span> is known, which in the present problem implies that <span class="math notranslate nohighlight">\(v=0\)</span> for <span class="math notranslate nohighlight">\(y=\pm h\)</span>. The second term on the right-hand side of <a class="reference internal" href="#equation-eq-secondorderint">(4)</a> therefore vanishes for the current problem and we are left with</p>
<div class="math notranslate nohighlight">
\[
-\int_\Omega \nabla u \cdot \nabla v \, \mathrm{d}x = \int_\Omega fv \, \mathrm{d}x\thinspace ,
\]</div>
<p>which is also referred to as the weak form of the original boundary value problem (<span class="math notranslate nohighlight">\(\nabla^2 u=f\)</span> with boundary conditions). The finite element method discretizes and solves this weak form of the problem on a domain divided into non-overlapping cells. In 2D we typically apply triangles, whereas in 3D tetrahedrons are applied. For 1D problems like the Couette flow we simply divide the computational domain <span class="math notranslate nohighlight">\(\Omega\)</span> into non-overlapping intervals.</p>
<p>The final step required for building a finite element solution is to choose an appropriate function space for our solution. A function space can for example be piecewise linear functions or piecewise polynomials of a higher degree. Different function spaces can be chosen for the trial and test functions, but in general they only differ on the boundaries.
The test and trial spaces <span class="math notranslate nohighlight">\(\hat{V}\)</span> and <span class="math notranslate nohighlight">\(V\)</span> are in the present problem defined as</p>
<div class="math notranslate nohighlight" id="equation-eq-testspace">
<span class="eqno">(5)<a class="headerlink" href="#equation-eq-testspace" title="Permalink to this equation">Â¶</a></span>\[\hat{V} = \{v \in H^1(\Omega) : v = 0 \text{ for } y=\pm h\},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-trialspace">
<span class="eqno">(6)<a class="headerlink" href="#equation-eq-trialspace" title="Permalink to this equation">Â¶</a></span>\[V = \{v \in H^1(\Omega) : v = 0 \text{ for } y=-h \text{ and } v=U for y=h\},\]</div>
<p>Briefly, <span class="math notranslate nohighlight">\(H^1(\Omega)\)</span> is known as the Sobolev space containing functions <span class="math notranslate nohighlight">\(v\)</span> such that <span class="math notranslate nohighlight">\(v^2\)</span> and <span class="math notranslate nohighlight">\(\|\nabla v\|^2\)</span> have finite integrals over <span class="math notranslate nohighlight">\(\Omega\)</span>. You will learn more about the Sobolev space in a basic finite element course. For now it will be sufficient to know that you need to choose a function space and for fluid flow it is usually appropriate to choose a space consisting of piecewise linear or quadratic polynomials.</p>
<p>Note that the proper mathematical statement of our variational problem now goes as follows: Find <span class="math notranslate nohighlight">\(u \in V\)</span> such that</p>
<div class="math notranslate nohighlight" id="equation-eq-varcouette">
<span class="eqno">(7)<a class="headerlink" href="#equation-eq-varcouette" title="Permalink to this equation">Â¶</a></span>\[-\int_{\Omega} \nabla u \cdot \nabla v \, \mathrm{d}x = \int_{\Omega} fv \, \mathrm{d}x \quad \forall v \in \hat{V}.\]</div>
<div class="section" id="implementation">
<h5>Implementation<a class="headerlink" href="#implementation" title="Permalink to this headline">Â¶</a></h5>
<p>The entire implementation that solves the variational problem <a class="reference internal" href="#equation-eq-varcouette">(7)</a> is given below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Couette flow</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">h</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">h</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="n">U</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">top</span><span class="p">)]</span>

<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">)</span>

<span class="n">u_exact</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;U/2*(1+x[0]/h)&quot;</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">211</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Couette flow&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">([])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">212</span><span class="p">)</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u_</span> <span class="o">-</span> <span class="n">u_exact</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Error&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>A more thorough tutorial for the Poisson equation is given in <a class="reference external" href="https://fenicsproject.org/docs/dolfin/dev/python/demos/poisson/demo_poisson.py.html">the online tutorial</a>. Here we will repeat only the most necessary steps. The first thing we need to do is to import all basic FEniCS functionality into the python environment</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This is typically the first line of most FEniCS scripts as it imports all necessary functionality like <code class="docutils literal notranslate"><span class="pre">Interval,</span> <span class="pre">FunctionSpace,</span> <span class="pre">Function,</span> <span class="pre">DirichletBC,</span> <span class="pre">UnitSquare</span></code> and much, much more. A computational mesh is then generated by dividing the computational domain (<span class="math notranslate nohighlight">\(\Omega = [-h, h]\)</span>) into N equally sized intervals, each of size <span class="math notranslate nohighlight">\(2h/\mathrm{N}\)</span></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="o">-</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>We now choose a piecewise linear solution by defining a function space over the mesh</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>Second order polynomials or higher may be chosen by using a higher number here, but for the current problem this will not enhance the accuracy since the analytical solution is linear. The trial and test functions <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span> are then declared, just as described leading up to <a class="reference internal" href="#equation-eq-varcouette">(7)</a>.</p>
<p>The current problem assigns a value for <span class="math notranslate nohighlight">\(u\)</span> on both boundaries, which is mathematically termed Dirichlet boundary conditions. To implement these Dirichlet conditions we first need to specify where the boundaries are using two python functions</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">bottom</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">h</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">def</span> <span class="nf">top</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>
</pre></div>
</div>
<p>Here x is an array representing position. It is an array of length equal to the number of spatial dimensions of the mesh. In our case it is an array of length 1. The boundary conditions are created using the FEniCS function <code class="docutils literal notranslate"><span class="pre">DirichletBC</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">U</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">bcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bottom</span><span class="p">),</span>
       <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">U</span><span class="p">,</span> <span class="n">top</span><span class="p">)]</span>
</pre></div>
</div>
<p>Note that by using brackets <span class="math notranslate nohighlight">\([\,]\)</span> the two boundary conditions are placed in a python list named bcs. The variational problem is solved by creating a <code class="docutils literal notranslate"><span class="pre">Function</span></code> to hold the solution and then calling the function <code class="docutils literal notranslate"><span class="pre">solve</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="o">-</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">==</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bcs</span><span class="p">)</span>
</pre></div>
</div>
<p>The <span class="math notranslate nohighlight">\(u_{-}\)</span> <code class="docutils literal notranslate"><span class="pre">Function</span></code> has <span class="math notranslate nohighlight">\(\mathrm{N}+1\)</span> unknowns, which are the solutions at the <span class="math notranslate nohighlight">\(\mathrm{N}+1\)</span> nodes of the mesh. However, it is important to remember that the finite element solution is not restricted to the nodes of the mesh. The finite element solution is the piecewise continuous linear profiles, well defined over the entire elements. You can look at the discrete solution at the nodes on the command line as a numpy array using</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">u_</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>[1.  0.9 0.8 0.7 0.6 0.5 0.4 0.3 0.2 0.1 0. ]
</pre></div>
</div>
</div>
</div>
<p>We can put the exact solution in a FEniCS <code class="docutils literal notranslate"><span class="pre">Function</span></code> by projecting a known analytical solution as an <code class="docutils literal notranslate"><span class="pre">Expression</span></code> onto the same function space as the numerical solution:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u_exact</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;U/2*(1+x[0]/h)&quot;</span><span class="p">,</span> <span class="n">U</span><span class="o">=</span><span class="n">U</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> <code class="docutils literal notranslate"><span class="pre">u_exact</span></code> will now contain <span class="math notranslate nohighlight">\(\mathrm{N}+1\)</span> values, just like <code class="docutils literal notranslate"><span class="pre">u_</span></code>, and if we have computed correctly these values should be more or less the same as in <code class="docutils literal notranslate"><span class="pre">u_</span></code>. The plot above of the numerical solution minus the exact solution (<code class="docutils literal notranslate"><span class="pre">plot(u_</span> <span class="pre">-</span> <span class="pre">u_exact,</span> <span class="pre">title=&quot;Error</span> <span class="pre">couette</span> <span class="pre">flow&quot;)</span></code>) shows that the computed solution is exact down to machine precision <span class="math notranslate nohighlight">\(\approx 10^{-16}\)</span>. This is to be expected since the solution is linear and we are assuming a piecewise linear finite element solution.</p>
</div>
<div class="section" id="couette-flow-between-axially-moving-concentric-cylinders">
<h5>Couette flow between axially moving concentric cylinders<a class="headerlink" href="#couette-flow-between-axially-moving-concentric-cylinders" title="Permalink to this headline">Â¶</a></h5>
<p>The next example in Chapter 3-2.2 is the flow between axially moving concentric cylinders. The equation is the same as for the regular Couette flow in 3-2.1, but the coordinate system is cylindrical.
There is no applied pressure gradient and the flow is described by the Poisson equation with no source.</p>
<div class="math notranslate nohighlight" id="equation-eq-poissoncyl">
<span class="eqno">(8)<a class="headerlink" href="#equation-eq-poissoncyl" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{align}
  \nabla^2 u &amp;= 0, \\
  \frac{1}{r}\frac{\partial}{\partial r}\left(r\frac{\partial u}{\partial r} \right) &amp;= 0. 
\end{align}\end{split}\]</div>
<p>The two cylinders have diameters <span class="math notranslate nohighlight">\(r_0\)</span> and <span class="math notranslate nohighlight">\(r_1\)</span>, where <span class="math notranslate nohighlight">\(r_0&lt;r_1\)</span>. The Dirichlet boundary conditions are <span class="math notranslate nohighlight">\(u(r=r_0)=u_0\)</span> and <span class="math notranslate nohighlight">\(u(r=r_1)=u_1\)</span>. The solution to <a class="reference internal" href="#equation-eq-poissoncyl">(8)</a> can be found by integrating twice</p>
<div class="math notranslate nohighlight" id="equation-eq-ustep1">
<span class="eqno">(9)<a class="headerlink" href="#equation-eq-ustep1" title="Permalink to this equation">Â¶</a></span>\[  u(r) = C_1 \ln(r) + C_2,\]</div>
<p>where the two integration constants are found using the boundary conditions leading to</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
 C_1 &amp;= \frac{U_1-U_0}{\ln(r_1/r_0)} \\
 C_2 &amp;= U_0\frac{\ln(r_1)}{\ln(r_1/r_0)} - U_1 \frac{\ln(r_0)}{\ln(r_1/r_0)}
\end{align}
\end{split}\]</div>
<p>which inserted into <a class="reference internal" href="#equation-eq-ustep1">(9)</a> gives</p>
<div class="math notranslate nohighlight" id="equation-eq-uaxcyl">
<span class="eqno">(10)<a class="headerlink" href="#equation-eq-uaxcyl" title="Permalink to this equation">Â¶</a></span>\[ u(r) = U_0\frac{\ln(r_1/r)}{\ln(r_1/r_0)} + U_1\frac{\ln(r/r_0)}{\ln(r_1/r_0)}.\]</div>
<p>Eq. <a class="reference internal" href="#equation-eq-uaxcyl">(10)</a> is exactly the sum of Eqs.~(3-18) and (3-19), which is a result of the governing equation being linear.</p>
<p>The variational formulation of the problem reads</p>
<div class="math notranslate nohighlight">
\[
-\int_\Omega \nabla u \cdot \nabla v \, \mathrm{d}x = \int_\Omega fv \, \mathrm{d}x\thinspace ,
\]</div>
<p>but in Cylindrical coordinates the volume integral needs to be transformed (<span class="math notranslate nohighlight">\(\mathrm{d}x = r\mathrm{d}r2\pi L\)</span>, assuming the cylinder has length <span class="math notranslate nohighlight">\(L\)</span>) and the variational problem becomes</p>
<div class="math notranslate nohighlight">
\[
-\int_\Omega \nabla u \cdot \nabla v \, r \mathrm{d}r = \int_\Omega fv r \, \mathrm{d}r\thinspace.
\]</div>
<p>Note that the gradient requires no special treatment since the gradient component in the <span class="math notranslate nohighlight">\(r\)</span>-direction is unchanged in cylindrical coordinates.</p>
<p>A FEniCS implementation for axially moving concentric cylinders is shown below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Couette flow between two axially moving cylinders</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">parameters</span><span class="p">[</span><span class="s1">&#39;reorder_dofs_serial&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

<span class="n">r0</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">r1</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">u0</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">u1</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">IntervalMesh</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">inner_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="k">def</span> <span class="nf">outer_boundary</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">on_boundary</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">near</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">on_boundary</span>

<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u0</span><span class="p">,</span> <span class="n">inner_boundary</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">outer_boundary</span><span class="p">)</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;x[0]&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">==</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">dx</span>

<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="c1"># Compute all three subproblems (3-2) and plot in the same figure</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">u00</span><span class="p">,</span> <span class="n">u11</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]):</span>
    <span class="n">u0</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u00</span><span class="p">)</span>
    <span class="n">u1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u11</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u_</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">get_local</span><span class="p">(),</span> <span class="n">mesh</span><span class="o">.</span><span class="n">coordinates</span><span class="p">())</span>

<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s2">&quot;(a) U=1&quot;</span><span class="p">,</span> <span class="s2">&quot;(b) U=-1&quot;</span><span class="p">,</span> <span class="s2">&quot;(c) U=2&quot;</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;lower left&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Velocity&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>

<span class="n">u_exact</span> <span class="o">=</span> <span class="p">(</span><span class="n">u1</span><span class="o">-</span><span class="n">u0</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">r1</span><span class="o">/</span><span class="n">r0</span><span class="p">)</span> <span class="o">+</span> <span class="n">u0</span> <span class="o">-</span> <span class="p">(</span><span class="n">u1</span><span class="o">-</span><span class="n">u0</span><span class="p">)</span><span class="o">*</span><span class="n">ln</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">r1</span><span class="o">/</span><span class="n">r0</span><span class="p">)</span>
<span class="n">u_exact</span> <span class="o">=</span> <span class="n">project</span><span class="p">(</span><span class="n">u_exact</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error &#39;</span><span class="p">,</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">u_exact</span><span class="p">,</span> <span class="n">degree_rise</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Error  2.7838640479591485e-05
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="unsteady-couette-flows">
<h5>Unsteady Couette flows<a class="headerlink" href="#unsteady-couette-flows" title="Permalink to this headline">Â¶</a></h5>
<p>Transient behavior can be obtained for Couette type flows, where the velocity of the walls are either</p>
<ol class="simple">
<li><p>Suddenly accelerated to a constant velocity <span class="math notranslate nohighlight">\(u_{wall}=U_0\)</span></p></li>
<li><p>Oscillated as a function of time, i.e., <span class="math notranslate nohighlight">\(u_{wall}=f(t)\)</span>.</p></li>
</ol>
<p>The governing equation for these types of flow is the homogeneous heat equation</p>
<div class="math notranslate nohighlight">
\[
  \frac{\partial \boldsymbol{u}}{\partial t} = \nu \nabla^2 \boldsymbol{u}.
\]</div>
<p>We consider only parallel shear flows in Cartesian coordinates, where the velocity vector is
<span class="math notranslate nohighlight">\(\boldsymbol{u} = (u(y, t), 0, 0)\)</span> and the equation is reduced to</p>
<div class="math notranslate nohighlight" id="equation-eq-heat1d">
<span class="eqno">(11)<a class="headerlink" href="#equation-eq-heat1d" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial u}{\partial t} = \nu \frac{\partial^2 u}{\partial y^2}.\]</div>
<p>There are many different solutions available for this 1D heat equation, depending on the boundary and initial conditions of the problem. Most solutions make use of the Fourier series, the Fourier integral or Fourier transforms, see, e.g., <a class="bibtex reference internal" href="content/intro.html#kreyszig" id="id2">[Kre99]</a>.</p>
<p>As a first example of flow that is suddenly accelerated to  a constant velocity, consider a infinite plane normal to the <span class="math notranslate nohighlight">\(y\)</span>-axis located at <span class="math notranslate nohighlight">\(y=0\)</span> and initially at rest at <span class="math notranslate nohighlight">\(t=0\)</span>. The plane is then suddenly accelerated to a constant velocity <span class="math notranslate nohighlight">\(U_0\)</span> in the <span class="math notranslate nohighlight">\(x\)</span>-direction and remains at this velocity for all <span class="math notranslate nohighlight">\(t&gt;0\)</span>. Above the plane, for <span class="math notranslate nohighlight">\(y&gt;0\)</span>, the fluid is initially at rest. Friction and the no-slip boundary condition will make the flow above the plane increase in speed. Far away from the plane the velocity will be zero, i.e., <span class="math notranslate nohighlight">\(u(\infty, t)=0\)</span>. This means that the velocity will never reach a steady state, and the boundary layer over the plane will continue to grow for all time.</p>
<p>We can find the solution as before using a separation of variables, but first we normalize the velocity</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = \frac{u-U_0}{U_0},
\]</div>
<p>such that the boundary condition at <span class="math notranslate nohighlight">\(y=0\)</span> becomes homogeneous, i.e., <span class="math notranslate nohighlight">\(v(0, t)=0\)</span> for <span class="math notranslate nohighlight">\(t&gt;0\)</span>. The PDE for <span class="math notranslate nohighlight">\(v\)</span> is still <a class="reference internal" href="#equation-eq-heat1d">(11)</a>.</p>
<p>Start by separating variables</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = T(t)V(y).
\]</div>
<p>Inserted into <a class="reference internal" href="#equation-eq-heat1d">(11)</a> we get</p>
<div class="math notranslate nohighlight">
\[
  \frac{\dot{T}}{\nu T} = \frac{V''}{V} = K,
\]</div>
<p>where <span class="math notranslate nohighlight">\(K\)</span> is a constant. To obtain physically realistic solutions, the constant needs to be negative. This can be understood looking first at the transient part:</p>
<div class="math notranslate nohighlight">
\[
  \dot{T} = K \nu T,
\]</div>
<p>with solution</p>
<div class="math notranslate nohighlight">
\[
  T(t) = e^{K \nu t}.
\]</div>
<p>If <span class="math notranslate nohighlight">\(K\)</span> is positive, then the velocity will grow without bounds and without energy being added to the system. For the second equation we have</p>
<div class="math notranslate nohighlight">
\[
  V'' - K V = 0.
\]</div>
<p>If <span class="math notranslate nohighlight">\(K\)</span> is positive, then the solution is</p>
<div class="math notranslate nohighlight">
\[
  V(y) = A \sinh(\sqrt{K} y) + B \cosh (\sqrt{K} y).
\]</div>
<p>The boundary condition <span class="math notranslate nohighlight">\(V(0)=0\)</span> requires <span class="math notranslate nohighlight">\(B=0\)</span>. The remaining term <span class="math notranslate nohighlight">\(A\sinh (\sqrt{K} y)\)</span> grows without bounds as <span class="math notranslate nohighlight">\(y \longrightarrow \infty\)</span>, which is not in agreement with <span class="math notranslate nohighlight">\(v(\infty, t)=-1\)</span> and we have to assume that <span class="math notranslate nohighlight">\(K\)</span> is a negative constant that we can write as <span class="math notranslate nohighlight">\(K=-\lambda^2\)</span>. The solutions to the separated ordinary differential equations become</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  T(t) &amp;= e^{-\lambda^2 \nu t}, \\
  V(y) &amp;= A \sin(\lambda y) + B \cos(\lambda y).
\end{align*}
\end{split}\]</div>
<p>The constants need to be found using boundary and initial conditions. The boundary condition <span class="math notranslate nohighlight">\(V(0)=0\)</span> leads to <span class="math notranslate nohighlight">\(B=0\)</span> and as such one solution reads</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = A \sin (\lambda y) e^{-\lambda^2 \nu t}.
\]</div>
<p>To satisfy the initial condition we need to use more than one solution and through the superposition principle we can simply add solutions. A periodic Fourier series for <span class="math notranslate nohighlight">\(v\)</span> reads</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = \sum_{k=1}^{\infty} A_k \sin (\lambda_k y) e^{-\lambda_k^2 \nu t},
\]</div>
<p>where <span class="math notranslate nohighlight">\(A_k\)</span> are constants, <span class="math notranslate nohighlight">\(\lambda_k = k \pi / L\)</span> and <span class="math notranslate nohighlight">\(L\)</span> is the length of the periodic domain.</p>
<p>However, our domain is not periodic and it is unbounded for <span class="math notranslate nohighlight">\(y\longrightarrow \infty\)</span>. It turns out that for infinite domains and non-periodic solution, it is advantageous to work with Fourier integrals instead. A Fourier integral for our problem reads</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = \int_{0}^{\infty} A(\lambda) \sin (\lambda y) e^{-\lambda^2 \nu t} d\lambda.
\]</div>
<div class="figure align-default" id="heaviside">
<a class="reference internal image-reference" href="../_images/Heaviside.png"><img alt="../_images/Heaviside.png" src="../_images/Heaviside.png" style="width: 300px; height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 2 </span><span class="caption-text">The Heaviside function.</span><a class="headerlink" href="#heaviside" title="Permalink to this image">Â¶</a></p>
</div>
<p>and the âconstantâ <span class="math notranslate nohighlight">\(A(\lambda)\)</span> is a continuous function of <span class="math notranslate nohighlight">\(\lambda\)</span>. Since <span class="math notranslate nohighlight">\(v\)</span> only contains sinuses it is an odd function. As such, even though we are only interested in the domain <span class="math notranslate nohighlight">\(y &gt; 0\)</span> we can define an initial condition for <span class="math notranslate nohighlight">\(v(y, 0)\)</span> over the entire <span class="math notranslate nohighlight">\(-\infty&lt;y&lt;\infty\)</span> as an odd function</p>
<div class="math notranslate nohighlight">
\[
  v(y, 0) = 1-2\boldsymbol{H}(y) = \int_{0}^{\infty} A(\lambda) \sin (\lambda y) d\lambda, \, \mathrm{for } -\infty &lt; y &lt; \infty,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{H(y)}\)</span> is the Heaviside function.</p>
<p>This way <span class="math notranslate nohighlight">\(v(y, 0) = 1\)</span> for <span class="math notranslate nohighlight">\(y&lt;0\)</span>, <span class="math notranslate nohighlight">\(v(y, 0)=-1\)</span> for <span class="math notranslate nohighlight">\(y&gt;0\)</span> and by symmetry <span class="math notranslate nohighlight">\(v(0, 0)=0\)</span>. Through orthogonality and the initial condition we can find <span class="math notranslate nohighlight">\(A(\lambda)\)</span> as (see <a class="bibtex reference internal" href="content/intro.html#kreyszig" id="id3">[Kre99]</a>)</p>
<div class="math notranslate nohighlight">
\[
 A(\lambda) = -\frac{2}{\pi}\int_{0}^{\infty} \sin(\lambda y') dy' .
\]</div>
<p>Inserted into the total solution we get</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = -\frac{2}{\pi} \int_{0}^{\infty} \int_{0}^{\infty} \sin(\lambda y') dy' \sin (\lambda y) e^{-\lambda^2 \nu t} d\lambda,
\]</div>
<p>which can be rewritten by changing the order of integration as</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = -\frac{2}{\pi} \int_{0}^{\infty} \int_{0}^{\infty} \sin(\lambda y') \sin (\lambda y) e^{-\lambda^2 \nu t} d\lambda dy'.
\]</div>
<p>The inner integral can be transformed using <span class="math notranslate nohighlight">\(\sin(\lambda y)\sin(\lambda y') = 0.5 (\cos \lambda(y-y') - \cos \lambda(y+y'))\)</span></p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = -\frac{2}{\pi} \int_{0}^{\infty} \int_{0}^{\infty}  e^{-\lambda^2 \nu t} \frac{1}{2} \left(\cos \lambda(y-y') - \cos \lambda(y+y') \right) d\lambda dy'.
\]</div>
<p>The inner integrals can then be computed exactly since</p>
<div class="math notranslate nohighlight">
\[
  \int_{0}^{\infty}  e^{-\lambda^2 \nu t} \cos \lambda(y-y') \mathrm{d} \lambda = \sqrt{\frac{\pi}{4 \nu t}} e^{-\left(\frac{y-y'}{2 \sqrt{\nu t}}\right)^2},
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
  \int_{0}^{\infty}  e^{-\lambda^2 \nu t} \cos \lambda(y+y') \mathrm{d} \lambda = \sqrt{\frac{\pi}{4 \nu t}} e^{-\left(\frac{y+y'}{2 \sqrt{\nu t}}\right)^2}.
\]</div>
<p>The solution now reads</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = -\sqrt{\frac{1}{4 \pi \nu t}} \int_{0}^{\infty} \left( e^{-\left(\frac{y-y'}{2 \sqrt{\nu t}}\right)^2} - e^{-\left(\frac{y+y'}{2 \sqrt{\nu t}}\right)^2} \right)  dy'.
\]</div>
<p>Using integration by substitution, the integrals can be reorganized into error functions</p>
<div class="math notranslate nohighlight">
\[
  \mathrm{erf}(z) = \frac{2}{\sqrt{\pi}} \int_0^{z} e^{-u^2} \mathrm{d}u,
\]</div>
<p>if we simply use a change of variables</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
  u &amp;= \frac{y-y'}{2 \sqrt{\nu t}}, \quad \frac{\mathrm{d}u}{\mathrm{d} y'} = -\frac{1}{2\sqrt{\nu t}} \\
  u' &amp;= \frac{y+y'}{2 \sqrt{\nu t}}, \quad \frac{\mathrm{d}u}{\mathrm{d} y'} = \frac{1}{2\sqrt{\nu t}}
\end{align}
\end{split}\]</div>
<p>The integrals become</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\int_{0}^{\infty} e^{-\left(\frac{y-y'}{2 \sqrt{\nu t}}\right)^2}   dy' &amp;= -2\sqrt{\nu t} \int_{\frac{y}{2\sqrt{\nu t}}}^{-\infty} e^{-u^2} \mathrm{d}u,\\
    &amp;= -\sqrt{\nu t \pi}\left(1+ \mathrm{erf}\left(\frac{y}{2\sqrt{\nu t}}\right) \right)
\end{align}
\end{split}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
\int_{0}^{\infty} e^{-\left(\frac{y+y'}{2 \sqrt{\nu t}}\right)^2}   dy' &amp;= 2\sqrt{\nu t} \int_{\frac{y}{2\sqrt{\nu t}}}^{\infty} e^{-u^2} \mathrm{d}u,\\
    &amp;= \sqrt{\nu t \pi}\left(1- \mathrm{erf}\left(\frac{y}{2\sqrt{\nu t}}\right) \right).
\end{align}
\end{split}\]</div>
<p>Putting it all together we finally obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align}
  v(y, t) &amp;= -\sqrt{\frac{1}{4 \pi \nu t}} \left(-\sqrt{\nu t \pi} \right) (-2) \mathrm{erf}\left(\frac{y}{2\sqrt{\nu t}} \right), \\
  &amp;= -\mathrm{erf}\left(\frac{y}{2\sqrt{\nu t}} \right).
\end{align}
\end{split}\]</div>
<p>The original unnormalized velocity becomes</p>
<div class="math notranslate nohighlight" id="equation-eq-stokesfirst">
<span class="eqno">(12)<a class="headerlink" href="#equation-eq-stokesfirst" title="Permalink to this equation">Â¶</a></span>\[  u(y, t) = U_0\left(1-\mathrm{erf} \left(\frac{y}{2\sqrt{\nu t}} \right) \right),\]</div>
<p>in agreement with Eq. 3-107 in <a class="bibtex reference internal" href="content/intro.html#white06" id="id4">[Whi06]</a>. Profiles for the velocity above the plane is computed below, where the first plot includes the unphysical (mirror) domain.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erf</span>

<span class="n">nu</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">U0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="k">for</span> <span class="n">y0</span><span class="p">,</span> <span class="n">title</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Solution in extended domain&#39;</span><span class="p">,</span> <span class="s1">&#39;Solution in true domain&#39;</span><span class="p">)):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">200.</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">U0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">erf</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nu</span><span class="o">*</span><span class="n">t</span><span class="p">)))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">),</span>
                 <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span>
                 <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=-.15&quot;</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Velocity &quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;$u/U_0$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Position &quot;</span> <span class="o">+</span> <span class="s2">&quot;$y$&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="stderr docutils container">
<pre class="stderr literal-block">&lt;ipython-input-4-d4d1f923fc3d&gt;:11: RuntimeWarning: divide by zero encountered in true_divide
  u = U0*(1-erf(y/2/sqrt(nu*t)))
&lt;ipython-input-4-d4d1f923fc3d&gt;:11: RuntimeWarning: divide by zero encountered in true_divide
  u = U0*(1-erf(y/2/sqrt(nu*t)))
&lt;ipython-input-4-d4d1f923fc3d&gt;:11: RuntimeWarning: invalid value encountered in true_divide
  u = U0*(1-erf(y/2/sqrt(nu*t)))
</pre>
</div>
</div>
</div>
</div>
<div class="section" id="fluid-oscillation-above-an-infinite-plate">
<h5>Fluid oscillation above an infinite plate<a class="headerlink" href="#fluid-oscillation-above-an-infinite-plate" title="Permalink to this headline">Â¶</a></h5>
<p>An infinite plate oscillates with a velocity <span class="math notranslate nohighlight">\(u(0, t) = U_0 \cos (\omega t)\)</span>, which is the boundary condition to the fluid flow set in motion above the plate. We look for a âsteady stateâ solution <span class="math notranslate nohighlight">\(\boldsymbol{u} = (u(y), 0, 0)\)</span>, meaning that we look for a solution independent of initial conditions. This problem is also referred to as Stokes second problem.</p>
<p>Since the plate oscillates with frequency <span class="math notranslate nohighlight">\(\cos (\omega t)\)</span> a justified guessed solution is</p>
<div class="math notranslate nohighlight">
\[  u(y, t) = f(y) e^{i \omega t} .\]</div>
<p>Inserted into the unsteady 1D heat equation we obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  f i \omega \cancel{e^{i \omega t}} - \nu f^{''} \cancel{e^{i \omega t}} &amp;= 0, \\
  f^{''} - \frac{i \omega}{\nu}f &amp;= 0
\end{align*}
\end{split}\]</div>
<p>A general solution to this problem is</p>
<div class="math notranslate nohighlight">
\[
  f(y) = Ae^{-\sqrt{\frac{i\omega}{\nu}}y} + Be^{\sqrt{\frac{i\omega}{\nu}}y},
\]</div>
<p>where only the first leads to physically realistic real solutions for <span class="math notranslate nohighlight">\(y\longrightarrow \infty\)</span>, such that <span class="math notranslate nohighlight">\(B=0\)</span>. The boundary condition at <span class="math notranslate nohighlight">\(y=0\)</span> leads to</p>
<div class="math notranslate nohighlight">
\[
  u(0, t) = f(0)e^{i \omega t} = A e^{i \omega t},
\]</div>
<p>where the real part then requires <span class="math notranslate nohighlight">\(A=U_0\)</span> and as such</p>
<div class="math notranslate nohighlight">
\[
 u(y, t) = U_0  e^{ -\sqrt{\frac{i\omega}{\nu}} y + i \omega t}
\]</div>
</div>
<div class="section" id="unsteady-flow-between-two-infinite-plates">
<h5>Unsteady flow between two infinite plates<a class="headerlink" href="#unsteady-flow-between-two-infinite-plates" title="Permalink to this headline">Â¶</a></h5>
<p>Consider two infinite plates separated by a distance <span class="math notranslate nohighlight">\(h\)</span> containing fluid initially at rest at <span class="math notranslate nohighlight">\(t=0\)</span>. At <span class="math notranslate nohighlight">\(t=0\)</span> the velocity of the lower plate at <span class="math notranslate nohighlight">\(y=0\)</span> is suddenly accelerated to a velocity of <span class="math notranslate nohighlight">\(U_0\)</span> and the fluid above the plate starts to move due to friction and the no-slip boundary condition. The flow will approximate the steady linear Couette solution <span class="math notranslate nohighlight">\(U_0(1-y/h)\)</span> as <span class="math notranslate nohighlight">\(t \longrightarrow \infty\)</span>. Find the velocity between the plates as a function of time and space.</p>
<p>The velocity, <span class="math notranslate nohighlight">\(\boldsymbol{u}=(u(y), 0, 0)\)</span>, is parallel to the walls and described by the 1D heat equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  \frac{\partial u}{\partial t} - \nu \frac{\partial ^2 u}{\partial y^2} &amp;= 0, \quad \mathrm{ for }\quad 0 \leq y \leq h \\
  u(y, 0) &amp;= 0, \quad 0 &lt; y &lt; h \\
  u(0, t) &amp;= U_0, \\
  u(h, t) &amp;= 0
\end{align*}
\end{split}\]</div>
<p>Through a shift of variables and using the steady Couette solution <span class="math notranslate nohighlight">\(v(y, t) = u(y, t) - U_0(1-y/h)\)</span>, the problem can be redefined with homogeneous boundary conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  \frac{\partial v}{\partial t} - \nu \frac{\partial ^2 v}{\partial y^2} &amp;= 0, \quad \mathrm{ for }\quad 0 \leq y \leq h \\
  v(y, 0) &amp;= -U_0(1-y/h), \quad 0 &lt; y &lt; h \\
  v(0, t) &amp;= 0, \\
  v(h, t) &amp;= 0
\end{align*}
\end{split}\]</div>
<p>We can solve this problem easily using separation of variables <span class="math notranslate nohighlight">\(v(y, t) = T(t) V(y)\)</span>. Inserted into the heat equation we obtain as before</p>
<div class="math notranslate nohighlight">
\[
 \frac{\dot{T}}{\nu T} = \frac{V''}{V} = -\lambda^2
\]</div>
<p>and two ordinary differential equations for <span class="math notranslate nohighlight">\(T\)</span> and <span class="math notranslate nohighlight">\(V\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  T(t) &amp;= e^{-\lambda^2 \nu t}, \\
  V(y) &amp;= A\sin(\lambda y) + B \cos(\lambda y).
\end{align*}
\end{split}\]</div>
<p>The boundary conditions give us <span class="math notranslate nohighlight">\(B=0\)</span> and <span class="math notranslate nohighlight">\(\lambda = \lambda_n = n \pi / h\)</span> for <span class="math notranslate nohighlight">\(n=1,2,\ldots\)</span>. Using superposition we get the total solution for <span class="math notranslate nohighlight">\(v(y, t)\)</span>:</p>
<div class="math notranslate nohighlight">
\[
  v(y, t) = \sum_{n=1}^{\infty} A_n \sin(\lambda_n y) e^{-\lambda_n^2 \nu t},
\]</div>
<p>where the coefficients are found using the initial condition and orthogonality. That is,  multiply <span class="math notranslate nohighlight">\(v(y, 0)\)</span> by <span class="math notranslate nohighlight">\(\sin(\lambda_m)\)</span>, integrate from <span class="math notranslate nohighlight">\(0\)</span> to <span class="math notranslate nohighlight">\(h\)</span> and isolate <span class="math notranslate nohighlight">\(A_n\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  A_n &amp;= -\frac{2U_0}{h}\int_0^h \sin(\lambda_n y)(1-y/h) \mathrm{d}y \\
  A_n &amp;= -\frac{2 U_0}{n \pi}
\end{align*}
\end{split}\]</div>
<p>The total solution is then</p>
<div class="math notranslate nohighlight">
\[
  u(y, t) = U_0(1-y/h) - \frac{2U_0}{\pi}\sum_{n=1}^{\infty} \frac{\sin(\lambda_n y)}{n} e^{-\lambda_n^2 \nu t}.
\]</div>
</div>
<div class="section" id="suggested-assignments-couette">
<h5>Suggested assignments Couette<a class="headerlink" href="#suggested-assignments-couette" title="Permalink to this headline">Â¶</a></h5>
<div class="section" id="couette-problems-from-white">
<h6>Couette problems from White:<a class="headerlink" href="#couette-problems-from-white" title="Permalink to this headline">Â¶</a></h6>
<ol class="simple">
<li><p>Problem 3-1 <a id='problem-3-1'></a></p></li>
<li><p>Problem 3-2 <a id='problem-3-2'></a></p></li>
<li><p>Problem 3-3 <a id='problem-3-3'></a></p></li>
<li><p>Problem 3-4 <a id='problem-3-4'></a></p></li>
<li><p>Problem 3-5 <a id='problem-3-5'></a></p></li>
</ol>
</div>
<div class="section" id="additional-couette-problems">
<h6>Additional Couette problems:<a class="headerlink" href="#additional-couette-problems" title="Permalink to this headline">Â¶</a></h6>
<ol start='6'> 
    <li> Homogeneous heat equation with inhomogeneous boundary conditions <a id='problem-6'></a>
<p>Consider the homogeneous heat equation with inhomogeneous boundary conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  \frac{\partial u}{\partial t} - \nu \frac{\partial ^2 u}{\partial y^2} &amp;= 0, \quad \mathrm{ for }\quad 0 \leq y \leq L \\
  u(y, 0) &amp;= \phi(y), \\
  u(0, t) &amp;= g, \\
  u(L, t) &amp;= h
\end{aligned}
   \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> are constants. Find the general solution <span class="math notranslate nohighlight">\(u(y, t)\)</span>. Hint: use a function <span class="math notranslate nohighlight">\(\boldsymbol{U}(y) =
   1/L[(L-y)g + y h]\)</span> and find the solution of <span class="math notranslate nohighlight">\(v(y, t) = u(y, t) - \boldsymbol{U}(y)\)</span>. The equation for <span class="math notranslate nohighlight">\(v(y, t)\)</span> is
the same as for <span class="math notranslate nohighlight">\(u(y, t)\)</span>, but now with homogeneous boundary conditions.</p>
<p>Optional (difficult), find the general solution if <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> are functions of time. Two hints to the optional
assignment are</p>
<ul>
<li> 
Hint 1: use a function $\boldsymbol{U}(y, t) = 1/L[(L-y)g(t) + y h(t)]$ and find the solution of $v(y, t) = u(y,t)-\boldsymbol{U}(y,t)$. The equation for $v(y, t)$ should be obtained as an inhomogeneous heat equation with homogeneous boundary conditions.
</li>
<li> <a id='problem-6-hint-2'></a>
Hint 2: Use Duhamel's principle to solve the inhomogeneous heat equation. Duhamel's principle states that the solution to the inhomogeneous heat equation can be found through solving just the homogeneous part. An inhomogeneous heat equation for $v(y, t)$ reads
<p></p> 
$$
\begin{aligned}
  \frac{\partial v}{\partial t} - \nu \frac{\partial ^2 v}{\partial y^2} &= f(y, t), \quad \mathrm{ for }\quad 0 \leq y \leq L   \label{eq:Heat1DInhomo} \\
\notag  v(y, 0) &= \overline{\phi}(y), \\
\notag  v(0, t) &= v(L, t) = 0,
\end{aligned}
$$
<p></p>
We can solve instead the homogeneous part
<p></p>   
$$
\begin{aligned}
  \frac{\partial v^h}{\partial t} - \nu \frac{\partial ^2 v^h}{\partial y^2} &= 0, \quad \mathrm{ for }\quad 0 \leq y \leq L   \label{eq:Heat1DHomo} \\
\notag  v^h(y, 0) &= \overline{\phi}(y), \\
\notag  v^h(0, t) &= v^h(L, t) =  0,
\end{aligned}
$$
<p></p>
using for example a separation of variables $v^h(y,t)=S(t)V(y)$. The solution will evolve from the initial condition $\overline{\phi}$ and we thus expect the solution in a small increment of time to be expressed as $v^h(y, t) = S(t)\overline{\phi}(y)$. Duhamel's principle then states that the solution to the inhomogeneous problem can be computed as
<p></p>
$$
\begin{aligned}
  v(y, t) = v^h(y, t) + \int_0^t S(t-s)f(y, s)\mathrm{d}s,
\end{aligned}
$$
<p></p>
where $S(t-s)f(y, s)$ is the homogeneous solution we found earlier, but computed from the initial condition $f(y, s)$ instead of $\overline{\phi}$. One may think of $\int_0^t S(t-s)f(y, s)\mathrm{d}s$ as a superposition in time. Initialize using $f(y, s)$ and then move the solution an infinitesimal time forward using the homogeneous solution. By linearity, or superposition in time, one may add up, or integrate, the solution in time.<br>
<p></p>
<p>    </p>Duhamel's principle can be justified by computation. Insert for the inhomogeneous solution in the inhomogeneous equation
<p></p>
$$
\begin{aligned}
  \frac{\partial v}{\partial t} - \nu \frac{\partial^2 v}{\partial y^2} = \cancel{\frac{\partial v^h}{\partial t} - \nu \frac{\partial^2 v^h}{\partial y^2}} + \left( \frac{\partial }{\partial t} - \nu \frac{\partial^2 }{\partial y^2}  \right) \left( \int_0^t S(t-s)f(y, s)\mathrm{d}s\right)
\end{aligned}
$$
<p></p>
Use Leibniz rule for differentiation under the integral sign on the last part
<p></p>
$$
\begin{aligned}
  \frac{\partial v}{\partial t} - \nu \frac{\partial^2 v}{\partial y^2} &= S(t-t)f(y, t) + \int_0^t \left(\frac{\partial }{\partial t} - \nu \frac{\partial^2 }{\partial y^2}  \right) S(t-s)f(y, s)\mathrm{d}s, \\
 &= S(0)f(y, t) = f(y, t).
\end{aligned}
$$
<p></p>
The integral is zero since the integrand $S(t-s)f(y, s)$ is known to be a solution of the homogeneous heat equation.
</li>
</ul>
</li>
</ol>
</div>
</div>
<div class="section" id="computer-assignments-couette">
<h5>Computer assignments Couette<a class="headerlink" href="#computer-assignments-couette" title="Permalink to this headline">Â¶</a></h5>
<ol>
<li><p>Rotating cylinders. <a id='c-computer-1'></a></p>
<p>Validate the analytical results (3-22) and (3-23) in Chapter 3-2.3 of <a class="bibtex reference internal" href="content/intro.html#white06" id="id5">[Whi06]</a>, for flow between rotating concentric cylinders. Can you reproduce Eq.~(3-23)? <span class="xref std std-ref">problem6</span></p>
</li>
<li><p>Implement <a class="reference external" href="couette.ipynb#problem-6">problem 6</a>. <a id='c-computer-2'></a></p>
<p>Consider <a class="reference external" href="couette.ipynb#problem-6">problem 6</a> with suitable <span class="math notranslate nohighlight">\(g\)</span> and <span class="math notranslate nohighlight">\(h\)</span> and compare the analytical solution from the written assignment with a numerical implementation.</p>
</li>
</ol>
<p id="bibtex-bibliography-content/chapter3/couette-0"><dl class="citation">
<dt class="bibtex label" id="kreyszig"><span class="brackets">Kre99</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id3">2</a>)</span></dt>
<dd><p>Erwin Kreyszig. <em>Advanced Engineering mathematics</em>. Wiley, 8 edition, 1999.</p>
</dd>
<dt class="bibtex label" id="white06"><span class="brackets">Whi06</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id4">2</a>,<a href="#id5">3</a>)</span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
<span id="document-content/chapter3/poiseuille"></span><div class="section" id="poiseuille-flows">
<h4>Poiseuille flows<a class="headerlink" href="#poiseuille-flows" title="Permalink to this headline">Â¶</a></h4>
<div class="figure align-default" id="channel">
<a class="reference internal image-reference" href="../_images/channelprofile3.png"><img alt="../_images/channelprofile3.png" src="../_images/channelprofile3.png" style="width: 300px; height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 3 </span><span class="caption-text">Channel flow is a pressure driven Poiseuille flow</span><a class="headerlink" href="#channel" title="Permalink to this image">Â¶</a></p>
</div>
<p>Poiseuille flows are driven by pumps that forces the fluid to flow by modifying the pressure. Fluids flow naturally from regions of high pressure to regions of low pressure. Typical examples are cylindrical pipe flow and other duct flows. A fully developed plane channel flow is shown above. Fully developed Poiseuille flows exists only far from the entrances and exits of the ducts, where the flow is aligned parallel to the duct walls. If we assume the flow is in the x-direction, as shown in Fig. 3-6 of <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>, then the velocity vector is <span class="math notranslate nohighlight">\(\boldsymbol{u}(y,z,t)=(u(y,z,t),0,0)\)</span> and Navier-Stokes equations can be simplified to</p>
<div class="math notranslate nohighlight" id="equation-eq-planechannelns">
<span class="eqno">(13)<a class="headerlink" href="#equation-eq-planechannelns" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
  \frac{\partial u}{\partial t} &amp;= \nu \nabla ^2 u - \frac{1}{\rho}\frac{\mathrm{d} p}{\mathrm{d} x},  \\
  \frac{\partial u}{\partial x} &amp;= 0,
\end{aligned}\end{split}\]</div>
<p>The equations are still linear because the flow is aligned in one direction and convection is thus zero. The only difference from Couette flow is that there is a non-zero source term in the pressure gradient. The transient term on the left hand side is zero for stationary flows.</p>
<p>The total volume flow, <span class="math notranslate nohighlight">\(Q\)</span>, through any duct is found by integrating the velocity over the entire cross section, <span class="math notranslate nohighlight">\(C\)</span>, of the duct</p>
<div class="math notranslate nohighlight" id="equation-eq-q">
<span class="eqno">(14)<a class="headerlink" href="#equation-eq-q" title="Permalink to this equation">Â¶</a></span>\[  Q = \displaystyle{\int_{\mathrm{C}}} u \mathrm{d}A.\]</div>
<p>Using <a class="reference internal" href="#equation-eq-q">(14)</a> it is also possible to define an average velocity, <span class="math notranslate nohighlight">\(\overline{u}\)</span>, through the duct</p>
<div class="math notranslate nohighlight">
\[  \overline{u} = \frac{Q}{A}.\]</div>
<p>The average velocity is subsequently used to define the Reynolds number and certain friction factors - engineering tools used to classify duct flow.</p>
<div class="section" id="the-circular-pipe">
<h5>The circular pipe<a class="headerlink" href="#the-circular-pipe" title="Permalink to this headline">Â¶</a></h5>
<p>For a steady cylindrical pipe flow with radius <span class="math notranslate nohighlight">\(r_0\)</span> the solution to <a class="reference internal" href="#equation-eq-planechannelns">(13)</a> is found simply by integrating twice and applying boundary conditions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\nu}{r}\frac{\mathrm{d}}{\mathrm{d} r}\left(r \frac{\mathrm{d} u}{\mathrm{d} r} \right) &amp;= \frac{1}{\rho}\frac{\mathrm{d} p}{\mathrm{d} x}, \\
  \frac{\mathrm{d}}{\mathrm{d} r}\left( r \frac{\mathrm{d} u }{\mathrm{d} r} \right) &amp;= \frac{r}{\mu}\frac{\mathrm{d} p}{\mathrm{d} x}, \\
   r \frac{\mathrm{d} u}{\mathrm{d} r} &amp;= \frac{r^2}{2\mu}\frac{\mathrm{d} p}{\mathrm{d} x} + C_1, \\
   \frac{\mathrm{d} u}{\mathrm{d} r} &amp;= \frac{r}{2\mu}\frac{\mathrm{d} p}{\mathrm{d} x} + \frac{C_1}{r}, \\
u(r) &amp;= \frac{r^2}{4\mu}\frac{\mathrm{d} p}{\mathrm{d} x} + C_1\ln(r)+ C_2,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(C_1\)</span> and <span class="math notranslate nohighlight">\(C_2\)</span> are integration constants. The constant <span class="math notranslate nohighlight">\(C_1\)</span> must be zero for the flow at the center of the pipe to remain finite. The condition at the wall <span class="math notranslate nohighlight">\(u(r_0)=0\)</span> gives</p>
<div class="math notranslate nohighlight">
\[  C_2 = -\frac{r_0^2}{4\mu}\frac{\partial p}{\partial x},\]</div>
<p>which leads to the final expression for the pipe flow</p>
<div class="math notranslate nohighlight" id="equation-eq-steadypoiseuille">
<span class="eqno">(15)<a class="headerlink" href="#equation-eq-steadypoiseuille" title="Permalink to this equation">Â¶</a></span>\[  u(r) = -\frac{1}{4\mu}\frac{\partial p}{\partial x} \left(r_0^2 - r^2 \right)\]</div>
</div>
<div class="section" id="combined-couette-and-poiseuille-flow">
<h5>Combined Couette and Poiseuille flow<a class="headerlink" href="#combined-couette-and-poiseuille-flow" title="Permalink to this headline">Â¶</a></h5>
<p>It is possible to combine an applied pressure gradient with moving walls. Such flows are termed combined Couette-Poiseuille flows and they are governed by the Poiseuille \eqref{eq:planechannelNS}. The solution to a combined Couette-Poiseuille flow can be found as the sum of a Couette solution <span class="math notranslate nohighlight">\(u_c\)</span> using zero pressure gradient and a homogeneous Poiseuille solution <span class="math notranslate nohighlight">\(u_p\)</span> using zero velocity on walls. For a plane channel with <span class="math notranslate nohighlight">\(u(h) = U\)</span> and <span class="math notranslate nohighlight">\(u(-h)=0\)</span> the solution is thus found by solving the two problems, for Couette</p>
<div class="math notranslate nohighlight" id="equation-eq-couettecomb">
<span class="eqno">(16)<a class="headerlink" href="#equation-eq-couettecomb" title="Permalink to this equation">Â¶</a></span>\[  \nabla^2 u_c = 0, \quad u_c(h)=U,\,u_c(-h)=0,\]</div>
<p>and Poiseuille</p>
<div class="math notranslate nohighlight" id="equation-eq-poiseuillecomb">
<span class="eqno">(17)<a class="headerlink" href="#equation-eq-poiseuillecomb" title="Permalink to this equation">Â¶</a></span>\[\nabla^2 u_p = \frac{1}{\mu}\frac{\mathrm{d}p}{\mathrm{d}x}, \quad u_p(\pm h)=0. \]</div>
<p>The combined solution <span class="math notranslate nohighlight">\(u = u_c + u_p\)</span> is the solution to the original problem. This can be seen by summing <a class="reference internal" href="#equation-eq-couettecomb">(16)</a> and <a class="reference internal" href="#equation-eq-poiseuillecomb">(17)</a> and also evidently <span class="math notranslate nohighlight">\(u(h) = u_c(h)+u_p(h) = U\)</span> and similarily for <span class="math notranslate nohighlight">\(y=-h\)</span>. The superposition is possible simply because the governing equation is linear. The principle is used also for transient flows in both Chapters (3-4) and (3-5).</p>
</div>
<div class="section" id="noncircular-ducts">
<h5>Noncircular ducts<a class="headerlink" href="#noncircular-ducts" title="Permalink to this headline">Â¶</a></h5>
<p>For steady and fully developed duct flows the governing equation is simply the Poisson equation</p>
<div class="math notranslate nohighlight" id="equation-eq-poisson">
<span class="eqno">(18)<a class="headerlink" href="#equation-eq-poisson" title="Permalink to this equation">Â¶</a></span>\[  \nabla ^2 u = \frac{1}{\mu} \frac{\mathrm{d}p}{\mathrm{d}x}.\]</div>
<p>The equation is linear and very easy to solve numerically for any shape of the duct. There is also a great number of analytical solutions available for noncircular duct flows, solutions that can be used to verify the quality of the numerical software. The duct solutions are often used for specifying inlet profiles to much more complicating geometries, where the flow enters the geometry through a duct.</p>
<p>In the code blelow we show a FEniCS code used to solve <a class="reference internal" href="#equation-eq-poisson">(18)</a> for a rectangular duct spanned as <span class="math notranslate nohighlight">\(-a \leqslant y \leqslant a\)</span> and <span class="math notranslate nohighlight">\(-b \leqslant z \leqslant b\)</span> . Of interest here is the computation of the very complicated analytical expression for the velocity given as</p>
<div class="math notranslate nohighlight" id="equation-eq-rectangle">
<span class="eqno">(19)<a class="headerlink" href="#equation-eq-rectangle" title="Permalink to this equation">Â¶</a></span>\[  u(z,y) = \frac{16a^2}{\mu \pi^3}\left(-\frac{\mathrm{d}p}{\mathrm{d}x} \right) \sum_{i=1,3,5,...}^{\infty} (-1)^{\frac{i-1}{2}} \left[1-\frac{\cosh (i \pi z)/2a}{\cosh (i \pi b) / 2a} \right] \times \frac{\cos(i \pi y) / 2a}{i^3}.\]</div>
<p>The FEniCS implementation of this exact solution overloads the <code class="docutils literal notranslate"><span class="pre">UserExpression</span></code> class and  you should recognize <a class="reference internal" href="#equation-eq-rectangle">(19)</a> in the overloaded <code class="docutils literal notranslate"><span class="pre">eval</span></code> method. Here <span class="math notranslate nohighlight">\(x\)</span> is an array of the coordinates and <span class="math notranslate nohighlight">\(x[0]\)</span> and <span class="math notranslate nohighlight">\(x[1]\)</span> represent <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> respectively. Unfortunately, the Python <code class="docutils literal notranslate"><span class="pre">UserExpression</span></code> <code class="docutils literal notranslate"><span class="pre">u_exact</span></code> is quite slow to interpolate due to the non-vectorized for-loop. For this reason, a C++ version of the same <code class="docutils literal notranslate"><span class="pre">Expression</span></code> is implemented instead, which speeds up the program with approximately a factor of 45.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">cosh</span><span class="p">,</span> <span class="n">cos</span>
<span class="n">set_log_active</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

<span class="n">dpdx</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="o">-</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">factor</span> <span class="o">=</span> <span class="mf">16.</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">/</span><span class="n">mu</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">pi</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">dpdx</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="k">class</span> <span class="nc">u_exact</span><span class="p">(</span><span class="n">UserExpression</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">u</span> <span class="o">+=</span> <span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">((</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosh</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">/</span>
                   <span class="n">cosh</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">a</span><span class="p">))</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="o">/</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="n">i</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> <span class="o">*</span> <span class="n">factor</span>

<span class="c1"># Much faster C++ version</span>
<span class="n">ue_code</span> <span class="o">=</span> <span class="s1">&#39;&#39;&#39;</span>
<span class="s1">#include &lt;pybind11/pybind11.h&gt;</span>
<span class="s1">#include &lt;pybind11/eigen.h&gt;</span>
<span class="s1">namespace py = pybind11;</span>

<span class="s1">#include &lt;dolfin/function/Expression.h&gt;</span>

<span class="s1">class U : public dolfin::Expression</span>
<span class="s1">{</span>
<span class="s1">  public:</span>

<span class="s1">    double a, b, mu, dpdx;</span>

<span class="s1">  void eval(Eigen::Ref&lt;Eigen::VectorXd&gt; values,</span>
<span class="s1">            Eigen::Ref&lt;const Eigen::VectorXd&gt; x,</span>
<span class="s1">            const ufc::cell&amp; cell) const override</span>
<span class="s1">    {</span>
<span class="s1">      double u = 0.;</span>
<span class="s1">      double factor = 16.*a*a/mu/pow(DOLFIN_PI, 3)*(-dpdx);</span>
<span class="s1">      for (std::size_t i=1; i&lt;500; i=i+2)</span>
<span class="s1">        u += pow(-1, (i-1)/2 % 2)*(1.-cosh(i*DOLFIN_PI*x[1]/2./a)/</span>
<span class="s1">           cosh(i*DOLFIN_PI*b/2./a))*cos(i*DOLFIN_PI*x[0]/2./a)/pow(i, 3);</span>
<span class="s1">      values[0] = u*factor;</span>
<span class="s1">    }</span>
<span class="s1">};</span>

<span class="s1">PYBIND11_MODULE(SIGNATURE, m)</span>
<span class="s1">{</span>
<span class="s1">  py::class_&lt;U, std::shared_ptr&lt;U&gt;, dolfin::Expression&gt;</span>
<span class="s1">    (m, &quot;U&quot;)</span>
<span class="s1">    .def(py::init&lt;&gt;())</span>
<span class="s1">    .def_readwrite(&quot;a&quot;, &amp;U::a)</span>
<span class="s1">    .def_readwrite(&quot;b&quot;, &amp;U::b)</span>
<span class="s1">    .def_readwrite(&quot;mu&quot;, &amp;U::mu)</span>
<span class="s1">    .def_readwrite(&quot;dpdx&quot;, &amp;U::dpdx);</span>
<span class="s1">}</span>
<span class="s1">&#39;&#39;&#39;</span>
<span class="n">u_c</span> <span class="o">=</span> <span class="n">CompiledExpression</span><span class="p">(</span><span class="n">compile_cpp_code</span><span class="p">(</span><span class="n">ue_code</span><span class="p">)</span><span class="o">.</span><span class="n">U</span><span class="p">(),</span> <span class="n">a</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">),</span>
                         <span class="n">mu</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">mu</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">dpdx</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">dpdx</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">RectangleMesh</span><span class="p">(</span><span class="n">Point</span><span class="p">(</span><span class="o">-</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">),</span> <span class="n">Point</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="n">degree</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="mi">1</span><span class="o">/</span><span class="n">mu</span><span class="o">*</span><span class="n">dpdx</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DomainBoundary</span><span class="p">())</span>
    <span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="n">bc</span><span class="p">)</span>

    <span class="c1">#u_e = interpolate(u_exact(), V)  # slow, but otherwise the same as below</span>
    <span class="n">u_e</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">u_c</span><span class="p">,</span> <span class="n">V</span><span class="p">)</span>
    <span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">u_e</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
    <span class="n">u_error</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_e</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">degree_rise</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u_error</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">hmin</span><span class="p">()</span>

<span class="n">E</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">h</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">degree</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">]:</span>
    <span class="n">ei</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
    <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;h=</span><span class="si">%2.2E</span><span class="s2"> E=</span><span class="si">%2.2E</span><span class="s2"> r=</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>h=4.47E-01 E=6.41E-03 r=1.76
h=2.24E-01 E=1.69E-03 r=1.93
h=1.12E-01 E=4.28E-04 r=1.98
h=7.45E-02 E=1.91E-04 r=1.99
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="analysing-the-error">
<h5>Analysing the error<a class="headerlink" href="#analysing-the-error" title="Permalink to this headline">Â¶</a></h5>
<p>In the code for the rectangular duct we compute the errornorm that compares the computed finite element solution with the exact solution. This error will depend on the mesh size and the order of the polynomial approximation. The error should disappear in the limit of a highly resolved mesh or for very high order polynomials. Given the polynomial order, the rate at which the error disappears can be computed by performing experiments with meshes of different resolution. We assume that the error for a mesh of element size <span class="math notranslate nohighlight">\(h_i\)</span> can be written as <span class="math notranslate nohighlight">\(E_i=Ch_i^r\)</span>, where <span class="math notranslate nohighlight">\(C\)</span> is a constant. We now want to find the order <span class="math notranslate nohighlight">\(r\)</span> of which the error disappears with mesh refinement. The order <span class="math notranslate nohighlight">\(r\)</span> can be found by computing <span class="math notranslate nohighlight">\(E_i\)</span> for two different <span class="math notranslate nohighlight">\(h_i\)</span>âs, i.e., <span class="math notranslate nohighlight">\(E_i=h_i^r\)</span> and <span class="math notranslate nohighlight">\(E_{i-1}=h_{i-1}^r\)</span>, and then isolate <span class="math notranslate nohighlight">\(r\)</span>:</p>
<div class="math notranslate nohighlight">
\[ r = \frac{\ln (E_i/E_{i-1})}{\ln (h_i/h_{i-1})}.\]</div>
<p>It is this error that is printed out at the end above. Changing the degree in the <code class="docutils literal notranslate"><span class="pre">FunctionSpace</span></code> to 2 the order should be three. Lets try it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">E</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">h</span> <span class="o">=</span> <span class="p">[];</span> <span class="n">degree</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">60</span><span class="p">]:</span>
    <span class="n">ei</span><span class="p">,</span> <span class="n">hi</span> <span class="o">=</span> <span class="n">main</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="n">degree</span><span class="p">)</span>
    <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ei</span><span class="p">)</span>
    <span class="n">h</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hi</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">log</span> <span class="k">as</span> <span class="n">ln</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">ln</span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">ln</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;h=</span><span class="si">%2.2E</span><span class="s2"> E=</span><span class="si">%2.2E</span><span class="s2"> r=</span><span class="si">%.2f</span><span class="s2">&quot;</span> <span class="o">%</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">r</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>h=4.47E-01 E=2.14E-04 r=3.13
h=2.24E-01 E=2.63E-05 r=3.03
h=1.12E-01 E=3.25E-06 r=3.02
h=7.45E-02 E=9.41E-07 r=3.05
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="unsteady-duct-flows">
<h5>Unsteady duct flows<a class="headerlink" href="#unsteady-duct-flows" title="Permalink to this headline">Â¶</a></h5>
<p>Unsteady plane shear flows are experienced by fluids where the driving forces are suddenly or continuously changed. A fluid initially at rest will for example respond to a sudden increase in the pressure gradient (we suddenly start the pump) and the volume flow through the duct will then increase monotonically until steady state is reached. The applied pressure gradient may also vary in time. Another scenario is that a wall is suddenly or continuously set in motion, dragging with it the fluid initially at rest. Common for these flows is that the transient term in the Navier Stokes equations cannot be neglected.</p>
<div class="section" id="starting-flow-in-a-cylindrical-pipe">
<h6>Starting flow in a cylindrical pipe<a class="headerlink" href="#starting-flow-in-a-cylindrical-pipe" title="Permalink to this headline">Â¶</a></h6>
<p>When a fluid initially at rest suddenly is exposed to a constant pressure gradient, the fluid will start to move as a response to the applied forces and the flow will increase for some time until the steady state Poiseuille flow profile <a class="reference internal" href="#equation-eq-steadypoiseuille">(15)</a> is reached. For convenience we modify this equation slightly here and write it for the steady velocity <span class="math notranslate nohighlight">\(u_s\)</span> as</p>
<div class="math notranslate nohighlight">
\[  u_s = u_m \left(1-\tilde{r}^2 \right),\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[  u_m = -\frac{r_0^2}{4\mu}\frac{\partial p}{\partial x}\]</div>
<p>and <span class="math notranslate nohighlight">\(\tilde{r}=r/r_0\)</span>. We use the superposition principle and split the equation into two contributions</p>
<div class="math notranslate nohighlight">
\[  u(r, t) = v(r, t) + u_s(r),\]</div>
<p>where <span class="math notranslate nohighlight">\(u(r,t)\)</span> is the complete solution and <span class="math notranslate nohighlight">\(v(r,t)\)</span> is the solution to the homogeneous <a class="reference internal" href="#equation-eq-planechannelns">(13)</a> in cylinder coordinates:</p>
<div class="math notranslate nohighlight" id="equation-eq-unsteadycyl">
<span class="eqno">(20)<a class="headerlink" href="#equation-eq-unsteadycyl" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial v}{\partial t} = \nu \left( \frac{\partial ^2 v}{\partial r^2} + \frac{1}{r} \frac{\partial v}{\partial r} \right), \]</div>
<p>subject to boundary condition <span class="math notranslate nohighlight">\(v(r_0,t)=0\)</span> and initial condition <span class="math notranslate nohighlight">\(v(r,0) = -u_s(r)\)</span>. The equation can be non-dimensionalized by multiplying with <span class="math notranslate nohighlight">\(r_0^2/\nu\)</span> and using <span class="math notranslate nohighlight">\(\tilde{t}=t\nu/r_0^2\)</span> and <span class="math notranslate nohighlight">\(\tilde{r}=r/r_0\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-unsteadycylnorm">
<span class="eqno">(21)<a class="headerlink" href="#equation-eq-unsteadycylnorm" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial v}{\partial \tilde{t}} = \frac{\partial ^2 v}{\partial \tilde{r}^2} + \frac{1}{\tilde{r}} \frac{\partial v}{\partial \tilde{r}}.\]</div>
<p>Equation <a class="reference internal" href="#equation-eq-unsteadycylnorm">(21)</a> can be solved using a separation of variables <span class="math notranslate nohighlight">\(v(\tilde{r},\tilde{t}) = V(\tilde{r})T(\tilde{t})\)</span>. Inserted into <a class="reference internal" href="#equation-eq-unsteadycylnorm">(21)</a> we obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 V \frac{\mathrm{d} T}{\mathrm{d} \tilde{t}} &amp;= T \left( \frac{\mathrm{d}^2 V}{\mathrm{d}\tilde{r}^2} + \frac{1}{\tilde{r}} \frac{\mathrm{d}V}{\mathrm{d}\tilde{r}} \right), \\
  V  \dot{T} &amp;= T \left( V^{''} + \frac{1}{\tilde{r}} V^{'} \right), \\
  \frac{\dot{T}}{T} &amp;= \frac{V^{''} + \frac{1}{\tilde{r}} V^{'}}{V},
\end{aligned}\end{split}\]</div>
<p>where the dot and apostrophe represent ordinary derivatives with respect to <span class="math notranslate nohighlight">\(\tilde{t}\)</span> and <span class="math notranslate nohighlight">\(\tilde{r}\)</span> respectively. Since the left hand side depends only on <span class="math notranslate nohighlight">\(\tilde{t}\)</span> and the right hand side only on <span class="math notranslate nohighlight">\(\tilde{r}\)</span>, both sides must be equal to a constant. It turns out that the constant must be negative to satisfy the appropriate boundary conditions. We call the new constant <span class="math notranslate nohighlight">\(-\lambda^2\)</span> and obtain the two separate ordinary differential equations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \dot{T} + \lambda^2 T &amp;= 0, \\
  \tilde{r}^2 V^{''} + \tilde{r} V^{'} + \lambda^2 \tilde{r}^2 V &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>The first equation has solution</p>
<div class="math notranslate nohighlight">
\[T(t) = e^{-\lambda^2 \tilde{t}}.\]</div>
<p>The second equation can be rewritten using <span class="math notranslate nohighlight">\(x=\tilde{r}\lambda\)</span> and chain rule differentiation leading to</p>
<div class="math notranslate nohighlight" id="equation-eq-besselequation">
<span class="eqno">(22)<a class="headerlink" href="#equation-eq-besselequation" title="Permalink to this equation">Â¶</a></span>\[ x^2 V^{''} + x V^{'} + x^2 V = 0,\]</div>
<p>with the apostrophe here being a derivative with respect to <span class="math notranslate nohighlight">\(x\)</span>. Equation <a class="reference internal" href="#equation-eq-besselequation">(22)</a> is Besselâs differential equation of zero order. The solution to Besselâs equation is the Bessel function of the first kind of order zero</p>
<div class="math notranslate nohighlight">
\[ J_0(x).\]</div>
<p>A solution to <span class="math notranslate nohighlight">\(V\)</span> becomes</p>
<div class="math notranslate nohighlight">
\[V(\tilde{r}) = A J_0(\lambda \tilde{r}),\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a constant. We now need to make sure that the boundary  and initial conditions are satisfied. The boundary condition requires
<span class="math notranslate nohighlight">\(V(1)=J_0(\lambda)=0\)</span>. The figure below shows how the Bessel function behaves. Apparently it looks somewhat like a damped cosine function with multiple roots that we call <span class="math notranslate nohighlight">\(\lambda_k\)</span>. The first four positive roots are located at  $ x = 2.4048, 5.5201, 8.6537, 11.7915$ corresponding to <span class="math notranslate nohighlight">\(\lambda_1, \lambda_2, \lambda_3, \lambda_4\)</span>.</p>
<div class="figure align-default" id="beselfunction">
<a class="reference internal image-reference" href="../_images/Besselplot.png"><img alt="../_images/Besselplot.png" src="../_images/Besselplot.png" style="width: 400px; height: 300px;" /></a>
<p class="caption"><span class="caption-number">Fig. 4 </span><span class="caption-text">Bessel function</span><a class="headerlink" href="#beselfunction" title="Permalink to this image">Â¶</a></p>
</div>
<p>One general solution is thus</p>
<div class="math notranslate nohighlight">
\[  V(\tilde{r}) = A_k J_0(\lambda_k \tilde{r})\]</div>
<p>with a total solution</p>
<div class="math notranslate nohighlight">
\[  v(\tilde{r}, \tilde{t}) = A_k J_0(\lambda_k \tilde{r})  e^{-\lambda_k^2 \tilde{t}}.\]</div>
<p>Since the equations are linear we can use superposition and obtain a total solution simply by summing over multiple possible solutions</p>
<div class="math notranslate nohighlight">
\[v(\tilde{r}, \tilde{t}) = \sum_{k=1}^{\infty} A_k J_0(\lambda_k \tilde{r})  e^{-\lambda_k^2 \tilde{t}}.\]</div>
<p>We now have a solution consisting of many constants that satisfy the boundary condition. It remains to close these constants using the initial condition <span class="math notranslate nohighlight">\(v(\tilde{r}, 0) = -u_m(1-\tilde{r}^2)\)</span>.</p>
<p>We have</p>
<div class="math notranslate nohighlight" id="equation-eq-besselinit">
<span class="eqno">(23)<a class="headerlink" href="#equation-eq-besselinit" title="Permalink to this equation">Â¶</a></span>\[  \sum_{k=1}^{\infty} A_k J_0(\lambda_k \tilde{r}) = -u_m(1-\tilde{r}^2)\]</div>
<p>and we want to find <span class="math notranslate nohighlight">\(A_k\)</span>. To this end we use orthogonality</p>
<div class="math notranslate nohighlight" id="equation-eq-besselorthogonal">
<span class="eqno">(24)<a class="headerlink" href="#equation-eq-besselorthogonal" title="Permalink to this equation">Â¶</a></span>\[ \int_0^1 x J_n(\lambda_k x) J_n(\lambda_m x) dx = 0 \quad \mathrm{for\,} k \neq m\]</div>
<p>and orthonormality</p>
<div class="math notranslate nohighlight" id="equation-eq-besselorthonormal">
<span class="eqno">(25)<a class="headerlink" href="#equation-eq-besselorthonormal" title="Permalink to this equation">Â¶</a></span>\[ \int_0^1 x J_n(\lambda_k x) J_n(\lambda_k x) dx = \frac{J_{n+1}^2(\lambda_k)}{2}.\]</div>
<p>If <a class="reference internal" href="#equation-eq-besselinit">(23)</a> is multiplied by <span class="math notranslate nohighlight">\(\tilde{r} J_0(\lambda_m \tilde{r})\)</span> and integrated from zero to unity we get</p>
<div class="math notranslate nohighlight">
\[  \int_0^1 \tilde{r} J_0(\lambda_m \tilde{r}) \sum_{k=1}^{\infty} A_k J_0(\lambda_k \tilde{r}) \mathrm{d}\tilde{r} = -\int_0^1 u_m(1-\tilde{r}^2) \tilde{r} J_0(\lambda_m \tilde{r}) \mathrm{d}\tilde{r}.\]</div>
<p>We now use <a class="reference internal" href="#equation-eq-besselorthogonal">(24)</a> to eliminate all terms on the left hand side where <span class="math notranslate nohighlight">\(k \neq m\)</span> and insert for <a class="reference internal" href="#equation-eq-besselorthonormal">(25)</a>. The result is a closed expression for <span class="math notranslate nohighlight">\(A_k\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-besselak">
<span class="eqno">(26)<a class="headerlink" href="#equation-eq-besselak" title="Permalink to this equation">Â¶</a></span>\[  A_k = -\frac{2}{J_1^2(\lambda_k)} \int_0^1 \tilde{r} J_0(\lambda_k \tilde{r})u_m(1-\tilde{r}^2) \mathrm{d}\tilde{r}.\]</div>
<p>The integral on the right hand side can be evaluated exactly (details left out for now) leading to</p>
<div class="math notranslate nohighlight" id="equation-eq-besselakfinal">
<span class="eqno">(27)<a class="headerlink" href="#equation-eq-besselakfinal" title="Permalink to this equation">Â¶</a></span>\[  A_k = -\frac{4 u_m J_2(\lambda_k)}{\lambda_k^2 J_1^2(\lambda_k)} = -\frac{8 u_m}{\lambda_k^3 J_1(\lambda_k)}\]</div>
<p>The final solution to starting flow in a cylinder, <a class="reference internal" href="#equation-eq-unsteadycyl">(20)</a>, becomes</p>
<div class="math notranslate nohighlight">
\[ u(\tilde{r}, \tilde{t}) = u_m(1 - \tilde{r}^2) - \sum_{k=1}^{\infty} \frac{8 u_m J_0(\lambda_k \tilde{r})}{\lambda_k^3 J_1(\lambda_k)} e^{-\lambda_k^2 \tilde{t}}\]</div>
<p>in agreement with Eq. (3-96) in White  <a class="bibtex reference internal" href="content/intro.html#white06" id="id2">[Whi06]</a>.</p>
</div>
<div class="section" id="pipe-flow-due-to-an-oscillating-pressure-gradient">
<h6>Pipe flow due to an oscillating pressure gradient<a class="headerlink" href="#pipe-flow-due-to-an-oscillating-pressure-gradient" title="Permalink to this headline">Â¶</a></h6>
<p>Consider now the same problem as in the previous section, but with a pressure gradient that is oscillating in time</p>
<div class="math notranslate nohighlight">
\[  \frac{\partial p}{\partial x} = -\rho K e^{i\omega t},\]</div>
<p>where <span class="math notranslate nohighlight">\(i = \sqrt{-1}\)</span> and</p>
<div class="math notranslate nohighlight">
\[  e^{i\omega t} = \cos \omega t + i \sin \omega t.\]</div>
<p>The governing equation for the cylinder is thus</p>
<div class="math notranslate nohighlight" id="equation-eq-unsteadycyl2">
<span class="eqno">(28)<a class="headerlink" href="#equation-eq-unsteadycyl2" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial u}{\partial t} = K e^{i\omega t} + \nu \left( \frac{\partial ^2 u}{\partial r^2} + \frac{1}{r} \frac{\partial u}{\partial r} \right).\]</div>
<p>We now want solve <a class="reference internal" href="#equation-eq-unsteadycyl2">(28)</a> with no-slip boundary conditions on the cylinder walls. We will neglect the initial condition and look only for a long-term steady oscillatory solution on the form</p>
<div class="math notranslate nohighlight" id="equation-eq-oscpressuresol">
<span class="eqno">(29)<a class="headerlink" href="#equation-eq-oscpressuresol" title="Permalink to this equation">Â¶</a></span>\[  u(r, t) = e^{i\omega t} V(r).\]</div>
<p>That is, we look for a solution where all the transient behaviour is governed by an oscillating pressure gradient proportional to <span class="math notranslate nohighlight">\(e^{i\omega t}\)</span>.</p>
<p>Inserting for <a class="reference internal" href="#equation-eq-oscpressuresol">(29)</a> in <a class="reference internal" href="#equation-eq-unsteadycyl2">(28)</a> and using the same nomenclature as in the previous section we obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  V i\omega \cancel{e^{i\omega t}} &amp;= K  \cancel{e^{i\omega t}} + \nu \cancel{e^{i\omega t}} \left(V'' + \frac{1}{r} V'\right) \\
  V i\omega &amp;= K + \nu \left(V'' + \frac{1}{r} V'\right) \\
  r^2 V'' + r V' - \frac{i\omega}{\nu} r^2 V &amp;= - \frac{K r^2}{\nu}.
\end{aligned}\end{split}\]</div>
<p>Using <span class="math notranslate nohighlight">\(x=r\sqrt{i\omega/\nu}\)</span> and chain rule differentiation the equation can be rewritten as</p>
<div class="math notranslate nohighlight" id="equation-eq-intermediatev">
<span class="eqno">(30)<a class="headerlink" href="#equation-eq-intermediatev" title="Permalink to this equation">Â¶</a></span>\[    x^2 V'' + x V' - x^2 V = - \frac{K x^2}{i \omega},\]</div>
<p>where the apostrophe now represents differentiation with respect to <span class="math notranslate nohighlight">\(x\)</span>. This equation looks very much like a <a class="reference external" href="http://mathworld.wolfram.com/ModifiedBesselDifferentialEquation.html">modified Bessel equation</a> of zero order. The only difference is the right hand side, which should be zero. To get rid of the right hand side we use another change of variables</p>
<div class="math notranslate nohighlight">
\[  V =  \hat{V} + \frac{K}{i \omega}\]</div>
<p>and insert this in <a class="reference internal" href="#equation-eq-intermediatev">(30)</a> such that</p>
<div class="math notranslate nohighlight">
\[    x^2 \hat{V}'' + x \hat{V}' - x^2 \hat{V} = 0.\]</div>
<p>The solution to the modified Bessel equation of zero order is the modified Bessel function of the first kind (the second kind cannot be used since this function is infinite for <span class="math notranslate nohighlight">\(x=0\)</span>) of zero order, <span class="math notranslate nohighlight">\(I_0\)</span>, so</p>
<div class="math notranslate nohighlight">
\[  \hat{V}(x) = A I_0(x),\]</div>
<p>or in terms of the ordinary Bessel function:</p>
<div class="math notranslate nohighlight">
\[  \hat{V}(x) = A J_0(-i x),\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a constant. With this result we can now express the total solution as</p>
<div class="math notranslate nohighlight" id="equation-eq-intoscpressuresol">
<span class="eqno">(31)<a class="headerlink" href="#equation-eq-intoscpressuresol" title="Permalink to this equation">Â¶</a></span>\[  u(r, t) = e^{i\omega t} \left(A I_0(r\sqrt{i\omega/\nu}) +  \frac{K}{i \omega} \right).\]</div>
<p>The boundary condition requires <span class="math notranslate nohighlight">\(u(r_0, t)=0\)</span>, which determines <span class="math notranslate nohighlight">\(A\)</span>:</p>
<div class="math notranslate nohighlight">
\[  A = -\frac{K}{i \omega I_0(r_0 \sqrt{i \omega/ \nu})}.\]</div>
<p>Inserted into <a class="reference internal" href="#equation-eq-intoscpressuresol">(31)</a> we are left with</p>
<div class="math notranslate nohighlight">
\[  u(r, t) = \frac{K e^{i\omega t}}{i \omega} \left( 1 - \frac{I_0(r \sqrt{i \omega})}{I_0(r_0 \sqrt{i \omega/\nu})} \right),\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[  u(r, t) = \frac{K e^{i\omega t}}{i \omega} \left( 1 - \frac{J_0(r \sqrt{-i \omega/\nu})}{J_0(r_0 \sqrt{-i \omega/\nu})} \right),\]</div>
<p>in accordance with Eq. 3-98 in <a class="bibtex reference internal" href="content/intro.html#white06" id="id3">[Whi06]</a>.</p>
<p>The Bessel function can be found in the toolbox <code class="docutils literal notranslate"><span class="pre">scipy.special</span></code>. The solution is computed below for a relatively large normalized <span class="math notranslate nohighlight">\(\tilde{\omega}=\omega r_0^2/\nu = 10\)</span>. A smaller value of <span class="math notranslate nohighlight">\(\tilde{\omega}\)</span> will result in velocity profiles closer to the steady Poiseuille profile <span class="math notranslate nohighlight">\(u_{max}(1-\tilde{r}^2)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">jv</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">r0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">w</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">K</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">nu</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="n">ws</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">r0</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">nu</span>

<span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">K</span><span class="o">/</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="n">w</span><span class="o">*</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">nu</span><span class="p">))</span><span class="o">/</span><span class="n">jv</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r0</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">/</span><span class="n">nu</span><span class="p">)))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="n">ll</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">w</span><span class="o">*</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">w</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="p">),</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">ll</span> <span class="o">+=</span> <span class="p">[</span><span class="sa">r</span><span class="s2">&quot;$t = </span><span class="si">{0}</span><span class="s2">\cdot \tau$&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">ll</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Velocity&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Radial position&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>0.0
10.471975511965978
20.943951023931955
31.415926535897928
41.88790204786391
52.35987755982989
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="suggested-assignments-poiseuille">
<h5>Suggested assignments Poiseuille<a class="headerlink" href="#suggested-assignments-poiseuille" title="Permalink to this headline">Â¶</a></h5>
</div>
<div class="section" id="poiseuille-problems-from-white">
<h5>Poiseuille problems from White<a class="headerlink" href="#poiseuille-problems-from-white" title="Permalink to this headline">Â¶</a></h5>
<ol class="simple">
<li><p>Problem 3-15 <a id='problem-3-15'></a></p></li>
<li><p>Problem 3-16 <a id='problem-3-16'></a></p></li>
<li><p>Problem 3-17 <a id='problem-3-17'></a></p></li>
</ol>
<div class="section" id="computer-exercise-poiseuille">
<h6>Computer exercise Poiseuille<a class="headerlink" href="#computer-exercise-poiseuille" title="Permalink to this headline">Â¶</a></h6>
<ol>
<li><p>Verify analytical solutions <a id='p-computer-1'></a></p>
<p>In <a class="bibtex reference internal" href="content/intro.html#white06" id="id4">[Whi06]</a> Chap. 3-3.3 there are 6 analytical solutions provided for 6 different types of ducts. Verify the analytical solutions (3-47), (3-49) and (3-52). Experiment with higher order âCGâ elements (the solution is then higher order continuous piecewise polynomials) and compute the <code class="docutils literal notranslate"><span class="pre">errornorm</span></code>. Does the error vanish for higher order polynomials for all ducts or does it remain constant?</p>
</li>
</ol>
<p id="bibtex-bibliography-content/chapter3/poiseuille-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets">Whi06</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id4">4</a>)</span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>
</div>
</div>
<span id="document-content/chapter3/similarity"></span><div class="section" id="similarity-solutions">
<h3>Similarity solutions<a class="headerlink" href="#similarity-solutions" title="Permalink to this headline">Â¶</a></h3>
<p>Similarity solutions are obtained when the number of independent variables describing a problem is reduced by at least one.</p>
<div class="section" id="stokes-first-problem-revisited">
<h4>Stokesâ first problem revisited<a class="headerlink" href="#stokes-first-problem-revisited" title="Permalink to this headline">Â¶</a></h4>
<p>We will first illustrate this by revisiting Stokesâ first problem - A fluid initially at rest in an infinite domain (<span class="math notranslate nohighlight">\(y\in[0, \infty)\)</span>) is suddenly set in motion by an infinite flat plate located at <span class="math notranslate nohighlight">\(y=0\)</span>.
The problem is described by the equations</p>
<div class="math notranslate nohighlight" id="equation-eq-stokesheat1d">
<span class="eqno">(32)<a class="headerlink" href="#equation-eq-stokesheat1d" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial u}{\partial t} &amp;= \nu \frac{\partial^2 u}{\partial y^2} \text{ for } y\in [0, \infty), \\
u(\infty, t) &amp;= 0, \\
u(y, t&lt;0) &amp;= 0 \\
u(0, t&gt;0) &amp;= U_0
\end{aligned}\end{split}\]</div>
<p>We have already found the solution to this problem using Fourier integrals with the solution as shown below</p>
<div class="cell tag_hide_input docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erf</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">nu</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">U0</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">200.</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">U0</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">erf</span><span class="p">(</span><span class="n">y</span><span class="o">/</span><span class="mi">2</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nu</span><span class="o">*</span><span class="n">t</span><span class="p">)))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">)</span>    
<span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">4.6</span><span class="p">),</span>
             <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">80</span><span class="p">,</span> <span class="o">-</span><span class="mi">90</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span> 
             <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s2">&quot;-&gt;&quot;</span><span class="p">,</span> <span class="n">connectionstyle</span><span class="o">=</span><span class="s2">&quot;arc3,rad=-.15&quot;</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Velocity &quot;</span> <span class="o">+</span> <span class="sa">r</span><span class="s2">&quot;$u/U_0$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Position &quot;</span> <span class="o">+</span> <span class="s2">&quot;$y$&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Stokes&#39; first problem&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>The solution is repeated here</p>
<div class="math notranslate nohighlight">
\[  u(y, t) = U_0\left(1-\mathrm{erf} \left(\frac{y}{2\sqrt{\nu t}} \right) \right).\]</div>
<p>We will now look at this problem again and try to find this solution using a similarity approach. First define a similarity variable</p>
<div class="math notranslate nohighlight">
\[ \eta = \frac{y}{2 \sqrt{\nu t}},\]</div>
<p>and observe that the solution can be written in terms of merely one variable</p>
<div class="math notranslate nohighlight">
\[  u(\eta) = U_0\left(1-\mathrm{erf} (\eta) \right).\]</div>
<p>Usually we donât know the solution and have to guess a similarity variable. Having defined <span class="math notranslate nohighlight">\(\eta\)</span>, the heat equation <a class="reference internal" href="#equation-eq-stokesheat1d">(32)</a> can be rewritten using chain rule differentiation</p>
<div class="math notranslate nohighlight">
\[  \frac{\mathrm{d} u}{\mathrm{d} \eta} \frac{\partial \eta}{\partial t} - \nu \left( \frac{\mathrm{d}^2 u}{\mathrm{d} \eta^2} \left( \frac{\partial \eta}{\partial y} \right)^2 + \frac{\mathrm{d} u}{\mathrm{d} \eta} \frac{\partial^2 \eta}{\partial y^2} \right) = 0.\]</div>
<p>The partial derivatives of <span class="math notranslate nohighlight">\(\eta\)</span> are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial \eta}{\partial t} &amp;= -\frac{\eta}{2 t}, \\
  \frac{\partial \eta}{\partial y} &amp;= \frac{1}{2\sqrt{\nu t}}, \\
  \frac{\partial^2 \eta}{\partial y^2} &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>Inserting this into the above leads to and ordinary differential equation for <span class="math notranslate nohighlight">\(u(\eta)\)</span>, which is exactly what we were hoping to achieve</p>
<div class="math notranslate nohighlight">
\[ 2\eta \frac{\mathrm{d} u}{\mathrm{d} \eta} + \frac{\mathrm{d}^2 u}{\mathrm{d} \eta^2} = 0.\]</div>
<p>This ordinary differential equation must be solved using boundary conditions <span class="math notranslate nohighlight">\(u(0) = U_0\)</span> and <span class="math notranslate nohighlight">\(u(\infty) = 0\)</span>. Define first <span class="math notranslate nohighlight">\(h(\eta) = \mathrm{d} u / \mathrm{d}\eta\)</span> and rewrite the ODE as</p>
<div class="math notranslate nohighlight">
\[  2\eta h + \frac{\mathrm{d} h}{\mathrm{d} \eta} = 0.\]</div>
<p>Separate variables and integrate to obtain</p>
<div class="math notranslate nohighlight">
\[  \frac{\mathrm{d} u}{\mathrm{d} \eta} = Ae ^{- \eta^2}.\]</div>
<p>Integrate one more time to obtain</p>
<div class="math notranslate nohighlight">
\[ u(\eta) = A\mathrm{erf} (\eta) + B\]</div>
<p>Inserting for the boundary conditions we finally get the original solution derived with much more effort in <a class="reference external" href="../chapter3/couette.ipynb#Unsteady-Couette-flows">Unsteady Couette</a>.</p>
</div>
<div class="section" id="plane-stagnation-flow">
<h4>Plane stagnation flow<a class="headerlink" href="#plane-stagnation-flow" title="Permalink to this headline">Â¶</a></h4>
<p>Another well known and much used similarity solution is the streamfunction <span class="math notranslate nohighlight">\(\psi(\boldsymbol{x}, t)\)</span>, that is most often used for two-dimensional flows, where it is defined through</p>
<div class="math notranslate nohighlight" id="equation-eq-streamfunction2d">
<span class="eqno">(33)<a class="headerlink" href="#equation-eq-streamfunction2d" title="Permalink to this equation">Â¶</a></span>\[ u = \frac{\partial \psi}{\partial y}, \quad v = -\frac{\partial \psi}{\partial x}.\]</div>
<p>In 2D the only non-zero component of the vorticity vector, <span class="math notranslate nohighlight">\(\omega_z\)</span>, is computed as</p>
<div class="math notranslate nohighlight">
\[  \omega_z = \frac{\partial v}{\partial x} - \frac{\partial u}{\partial y},\]</div>
<p>If this definition is combined with <a class="reference internal" href="#equation-eq-streamfunction2d">(33)</a> we obtain a Poisson equation for the streamfunction</p>
<div class="math notranslate nohighlight" id="equation-eq-eqstreamfunction2d">
<span class="eqno">(34)<a class="headerlink" href="#equation-eq-eqstreamfunction2d" title="Permalink to this equation">Â¶</a></span>\[  \nabla^2 \psi = -\omega_z.\]</div>
<p>The streamfunction is much used for inviscid irrotational flows, where the vorticity component <span class="math notranslate nohighlight">\(\omega_z=0\)</span>. However, the definition of the streamfunction is equally valid for viscous flows.</p>
<p>An illustration of plane stagnation flow is given in Fig. (3-24) of <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>. For inviscid flows the solution is trivially obtained as</p>
<div class="math notranslate nohighlight">
\[\psi = Bxy, \quad u = Bx, \quad v = -By,\]</div>
<p>where <span class="math notranslate nohighlight">\(B\)</span> is a positive constant. Make sure to check that the solution satisfies both <a class="reference internal" href="#equation-eq-eqstreamfunction2d">(34)</a> (with zero right hand side) and the continuity equation</p>
<div class="math notranslate nohighlight">
\[  \frac{\partial u}{\partial x} + \frac{\partial v}{\partial y} = 0.\]</div>
<p>For viscous flows it is somewhat more complicated, since the right hand side of <a class="reference internal" href="#equation-eq-eqstreamfunction2d">(34)</a> is nonzero. To find the solution for viscous flows we also need to consider the momentum equations in two dimensions</p>
<div class="math notranslate nohighlight" id="equation-eq-ns2d">
<span class="eqno">(35)<a class="headerlink" href="#equation-eq-ns2d" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
 \underline{u\frac{\partial u}{\partial x}} + v\frac{\partial u}{\partial y} &amp;= -\frac{1}{\rho}\frac{\partial p}{\partial x} + \nu \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2} \right), \notag \\
u\frac{\partial v}{\partial x} + \underline{v\frac{\partial v}{\partial y}} &amp;= -\frac{1}{\rho}\frac{\partial p}{\partial y} + \nu \left(\frac{\partial^2 v}{\partial x^2} + \frac{\partial^2 v}{\partial y^2} \right).
\end{aligned}\end{split}\]</div>
<p>These equations are nonlinear due to the two underlined terms and coupled through the continuity equation. Note that there are three equations for the three unknowns <span class="math notranslate nohighlight">\(u, v, p\)</span>, so the equations are closed. We will now look for a similarity solution through a modification of the streamfunction of the form</p>
<div class="math notranslate nohighlight">
\[ \psi_{\nu} = B x f(y), \quad u = \frac{\partial \psi_{\nu}}{\partial y} = Bx \frac{d f}{dy}, \quad v = -\frac{\partial \psi_{\nu}}{\partial x} = -Bf.\]</div>
<p>Using an apostrophe for the derivative of <span class="math notranslate nohighlight">\(f\)</span> with respect to <span class="math notranslate nohighlight">\(y\)</span> one has immediately</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial u}{\partial x} = B f^{\prime},\quad   \frac{\partial u}{\partial y} = Bx f^{\prime\prime}, \quad
  \frac{\partial^2 u}{\partial x^2} = 0,\quad   \frac{\partial^2 u}{\partial y^2} = Bx f^{\prime\prime\prime}, \\
  \frac{\partial v}{\partial x} = 0,\quad   \frac{\partial v}{\partial y} = -B f^{\prime}, \quad
  \frac{\partial^2 v}{\partial x^2} = 0,\quad   \frac{\partial^2 v}{\partial y^2} = -B f^{\prime\prime}.
\end{aligned}\end{split}\]</div>
<p>We immediately see that the continuity equation is satisfied. Inserting for the streamfunction in <a class="reference internal" href="#equation-eq-ns2d">(35)</a> we obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  B^2 x (f^{\prime})^2 - B^2 x f f^{\prime\prime} - \nu B x f^{\prime\prime\prime} = -\frac{1}{\rho} \frac{\partial p}{\partial x}, \\
  B^2 f f^{\prime} + \nu B f^{\prime\prime} = -\frac{1}{\rho} \frac{\partial p}{\partial y}
\end{aligned}\end{split}\]</div>
<p>The last equation here states that <span class="math notranslate nohighlight">\(\partial p/\partial y\)</span> is only a function of <span class="math notranslate nohighlight">\(y\)</span> and thus</p>
<div class="math notranslate nohighlight" id="equation-eq-pressure-stag">
<span class="eqno">(36)<a class="headerlink" href="#equation-eq-pressure-stag" title="Permalink to this equation">Â¶</a></span>\[ \frac{\partial^2 p}{\partial x \partial y} = 0.\]</div>
<p>The momentum equation in the <span class="math notranslate nohighlight">\(x\)</span>-direction can be simplified by dividing through by <span class="math notranslate nohighlight">\(- \nu B x\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-stagnation0">
<span class="eqno">(37)<a class="headerlink" href="#equation-eq-stagnation0" title="Permalink to this equation">Â¶</a></span>\[ f^{\prime\prime\prime} + \frac{B}{\nu} \left( f f^{\prime\prime} - (f^{\prime})^2\right)  = \frac{1}{\nu B x \rho} \frac{\partial p}{\partial x}\]</div>
<p>The left hand side is only a function of <span class="math notranslate nohighlight">\(y\)</span> and as such we need the right hand side also as a function of only <span class="math notranslate nohighlight">\(y\)</span>. For this to happen it is evident that the pressure derivative <span class="math notranslate nohighlight">\(\partial p / \partial x = \mathrm{const} \, x \, h(y)\)</span>, where <span class="math notranslate nohighlight">\(h(y)\)</span> is some function of <span class="math notranslate nohighlight">\(y\)</span>. However, from Eq. <a class="reference internal" href="#equation-eq-pressure-stag">(36)</a> it follows that <span class="math notranslate nohighlight">\(h\)</span> must be a constant as well and as such the right hand side of <a class="reference internal" href="#equation-eq-stagnation0">(37)</a> must be constant. Since the right hand side is constant, this means that the left hand side also must be a constant.</p>
<p>Treating the right hand side as a constant we can compute its value using the boundary conditions <span class="math notranslate nohighlight">\(f^{\prime}=1, f^{\prime \prime}=f^{\prime\prime\prime}=0\)</span> for <span class="math notranslate nohighlight">\(y\longrightarrow \infty\)</span> (the first follows from freestream condition <span class="math notranslate nohighlight">\(u_{viscous}=u_{inviscid}\)</span>). Inserted for the boundary conditions we obtain finally</p>
<div class="math notranslate nohighlight" id="equation-eq-stagnation">
<span class="eqno">(38)<a class="headerlink" href="#equation-eq-stagnation" title="Permalink to this equation">Â¶</a></span>\[ f^{\prime\prime\prime} + \frac{B}{\nu} \left( f f^{\prime\prime} - (f^{\prime})^2\right)  =- \frac{B}{\nu}.\]</div>
<p>Note that <a class="reference internal" href="#equation-eq-stagnation">(38)</a> is an exact equation for stagnation flow, since no terms have been eliminated in its derivation. The equation is nonlinear, which calls for iterative numerical solution techniques. The equation can be non-dimensionalised using length- and velocity-scales <span class="math notranslate nohighlight">\(\sqrt{\nu/B}\)</span> and <span class="math notranslate nohighlight">\(\sqrt{\nu B}\)</span> respectively, and the dimensionless variables</p>
<div class="math notranslate nohighlight" id="equation-eq-stagnationvars">
<span class="eqno">(39)<a class="headerlink" href="#equation-eq-stagnationvars" title="Permalink to this equation">Â¶</a></span>\[  \eta = y \sqrt{\frac{B}{\nu}}, \quad \psi = x F(\eta) \sqrt{B\nu}.\]</div>
<p>We can now easily obtain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  f(y) &amp;= F\sqrt{\frac{\nu}{B}}, \\
  f^{\prime} &amp;= \frac{dF}{d\eta}\frac{d\eta}{dy} \sqrt{\frac{\nu}{B}} = F^{\prime} \sqrt{\frac{B}{\nu}} \sqrt{\frac{\nu}{B}} = F^{\prime}, \\
  f^{\prime\prime} &amp;= \frac{dF^{\prime}}{d\eta}\frac{d\eta}{dy} = F^{\prime\prime}\sqrt{\frac{B}{\nu}}, \\
    f^{\prime\prime\prime} &amp;= \frac{dF^{\prime\prime}}{d\eta}\frac{d\eta}{dy} = F^{\prime\prime\prime}\frac{B}{\nu}.
\end{aligned}\end{split}\]</div>
<p>Inserted into <a class="reference internal" href="#equation-eq-stagnation">(38)</a> we obtain the dimensionless equation</p>
<div class="math notranslate nohighlight" id="equation-eq-stagnationnonnorm">
<span class="eqno">(40)<a class="headerlink" href="#equation-eq-stagnationnonnorm" title="Permalink to this equation">Â¶</a></span>\[  F^{\prime\prime\prime} + F F^{\prime\prime} + 1 - (F^{\prime})^2 = 0,\]</div>
<p>that can be solved using boundary conditions <span class="math notranslate nohighlight">\(F(0)=F^{\prime}(0)=0\)</span> and <span class="math notranslate nohighlight">\(F^{\prime}(\infty)=1\)</span>.</p>
</div>
<div class="section" id="axisymmetric-stagnation-flow">
<h4>Axisymmetric stagnation flow<a class="headerlink" href="#axisymmetric-stagnation-flow" title="Permalink to this headline">Â¶</a></h4>
<p>The plane stagnation flow discussed in the previous section is stagnant for a line in the <span class="math notranslate nohighlight">\(z\)</span>-plane located at <span class="math notranslate nohighlight">\(x=0\)</span>. Axisymmetric stagnation flow is similar in form, but only stagnant in a single point located at <span class="math notranslate nohighlight">\(x=y=z=0\)</span>. This axisymmetric flow is what you obtain by pointing a garden hose directly towards a plane wall (neglecting gravity). The equations are similar to the plane flow, but may be simplified using cylindrical coordinates. A streamfunction in cylindrical coordinates can be defined through</p>
<div class="math notranslate nohighlight" id="equation-eq-streamfunction2daxi">
<span class="eqno">(41)<a class="headerlink" href="#equation-eq-streamfunction2daxi" title="Permalink to this equation">Â¶</a></span>\[  u_{r} = -\frac{1}{r}\frac{\partial \psi}{\partial z}, \quad  u_{z} = \frac{1}{r}\frac{\partial \psi}{\partial r}\]</div>
<p>For axisymmetric flows with <span class="math notranslate nohighlight">\(u_{\theta}=0\)</span> the continuity equation reads</p>
<div class="math notranslate nohighlight">
\[  \frac{1}{r}\frac{\partial r u_r}{\partial r} + \frac{\partial u_z}{\partial z} = 0.\]</div>
<p>Inserting for <a class="reference internal" href="#equation-eq-streamfunction2daxi">(41)</a> it is easily verified that continuity is satisfied.</p>
<p>The streamfunction for axisymmetric inviscid flow towards a stagnation point is given as</p>
<div class="math notranslate nohighlight">
\[  \psi = -B r^2 z\]</div>
<p>which leads to velocity components</p>
<div class="math notranslate nohighlight">
\[  u_r = B r, \quad u_z = -2B z\]</div>
<p>For viscous flows one may obtain a dimensionless similarity solution using</p>
<div class="math notranslate nohighlight">
\[  \psi = - r^2 F(\eta) \sqrt{B \nu}, \quad \eta = z\sqrt{\frac{B}{\nu}}.\]</div>
<p>Inserting into the momentum equation for <span class="math notranslate nohighlight">\(u_{r}\)</span> the mathematics are very much like in the previous section leading to</p>
<div class="math notranslate nohighlight" id="equation-eq-axistagnationnonnorm">
<span class="eqno">(42)<a class="headerlink" href="#equation-eq-axistagnationnonnorm" title="Permalink to this equation">Â¶</a></span>\[  F^{\prime\prime\prime} + 2 F F^{\prime\prime} + 1 - (F^{\prime})^2 = 0.\]</div>
<p>This differs from plane stagnation flow only by the factor 2.</p>
</div>
<div class="section" id="suggested-assignments-similarity-solutions">
<h4>Suggested assignments similarity solutions<a class="headerlink" href="#suggested-assignments-similarity-solutions" title="Permalink to this headline">Â¶</a></h4>
<p id="bibtex-bibliography-content/chapter3/similarity-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets"><a class="fn-backref" href="#id1">Whi06</a></span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
<span id="document-content/chapter3/stokes"></span><div class="section" id="stokes-flow">
<h3>Stokes flow<a class="headerlink" href="#stokes-flow" title="Permalink to this headline">Â¶</a></h3>
<p>Flows at very low Reynolds numbers are often called <em>Stokes flow</em>. If the Navier-Stokes equations are nondimensionalized using the characteristic velocity <span class="math notranslate nohighlight">\(U\)</span> and length scale <span class="math notranslate nohighlight">\(L\)</span>, the equations can be simplified as</p>
<div class="math notranslate nohighlight" id="equation-eq-ns-nondim">
<span class="eqno">(43)<a class="headerlink" href="#equation-eq-ns-nondim" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\mathrm{Re}\left(  \frac{\partial \boldsymbol{\tilde{u}}}{\partial \tilde{t}} + (\boldsymbol{\tilde{u}} \cdot \tilde{\nabla})\boldsymbol{\tilde{u}} \right) &amp;= -\tilde{\nabla} \tilde{p} + \tilde{\nabla} ^2 \boldsymbol{\tilde{u}}, \\
  \tilde{\nabla} \cdot \boldsymbol{\tilde{u}} &amp;= 0,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\tilde{u}} = \boldsymbol{u}/U\)</span>, <span class="math notranslate nohighlight">\(\tilde{t}=tU/L\)</span>, <span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}=\boldsymbol{x}/L\)</span>, <span class="math notranslate nohighlight">\(\tilde{p}=p/(\mu U /L)\)</span> and <span class="math notranslate nohighlight">\(\mathrm{Re}=\rho U L / \mu\)</span>. The spatial derivative is taken with respect to <span class="math notranslate nohighlight">\(\tilde{\boldsymbol{x}}\)</span>, which explains the tilde on the nabla operator. The assumption for Stokes flow is that the Reynolds number is very small <span class="math notranslate nohighlight">\(\mathrm{Re} &lt;&lt; 1\)</span>, such that the acceleration term on the left hand side of Navier-Stokes can be neglected. Stokes flow is therefore governed, on dimensional form, by</p>
<div class="math notranslate nohighlight" id="equation-eq-stokes">
<span class="eqno">(44)<a class="headerlink" href="#equation-eq-stokes" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\mu\nabla ^2 \boldsymbol{u} &amp;= {\nabla} {p} ,  \\
  {\nabla} \cdot \boldsymbol{u} &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>Here the first (vector) equation is a momentum equation, whereas the second <span class="math notranslate nohighlight">\(\nabla \cdot \boldsymbol{u}\)</span> usually is referred to as the continuity eqaution.</p>
<p>Conveniently there is a <a class="reference external" href="https://fenicsproject.org/docs/dolfin/latest/python/demos/stokes-iterative/demo_stokes-iterative.py.html">FEniCS demo</a> available for solving the Stokes equations in a three-dimensional cubic
domain. In this demo the velocity and pressure are solved using a coupled
system of equations. That is, both equations in <a class="reference internal" href="#equation-eq-stokes">(44)</a>
are solved simultaneously as opposed to in a segregated, sequential manner.
Since the first equation in <a class="reference internal" href="#equation-eq-stokes">(44)</a> is a vector equation, this means that we are actually
solving 4 equations (if the domain is 3D) simultaneously. Both <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span> and <span class="math notranslate nohighlight">\(p\)</span>
are treated as unknowns (<code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code>s) using a mixed (coupled) functionspace.</p>
<p>The variational formulation for the Stokes equations is found by multiplying the vector equation in <a class="reference internal" href="#equation-eq-stokes">(44)</a> with <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code> <span class="math notranslate nohighlight">\(\boldsymbol{v}\)</span> and the continuity equation with <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code> <span class="math notranslate nohighlight">\(q\)</span> and then integrating over the domain</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\mu\int_{\Omega} \boldsymbol{v} \cdot \nabla ^2 \boldsymbol{u}\, \mathrm{d}x &amp;=  \int_{\Omega} \boldsymbol{v} \cdot {\nabla} {p}\, \mathrm{d}x, \\
  \int_{\Omega} q \, {\nabla} \cdot \boldsymbol{u} \,\mathrm{d}x &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>Both the Laplacian and pressure gradient are integrated by parts</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\mu \int_{\Gamma} \boldsymbol{v} \cdot (\nabla  \boldsymbol{u} \cdot \boldsymbol{n})\, \mathrm{d}s - \mu \int_{\Omega} \nabla \boldsymbol{v} : \nabla \boldsymbol{u}\, \mathrm{d}x &amp;= \int_{\Gamma} \boldsymbol{v} \cdot p\boldsymbol{n}\, \mathrm{d}s -\int_{\Omega} p\, \nabla \cdot \boldsymbol{v} \, \mathrm{d}x , \\
  \int_{\Omega} q\,  {\nabla} \cdot \boldsymbol{u} \,\mathrm{d}x &amp;= 0,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{n}\)</span> is the normal vector out of the domain and the colon represents an inner product (contraction) of two second order tensors. The boundary integral can be written as</p>
<div class="math notranslate nohighlight">
\[  \int_{\Gamma} \boldsymbol{v} \cdot \left( p \boldsymbol{I} -\mu \nabla  \boldsymbol{u}  \right) \cdot \boldsymbol{n}\, \mathrm{d}s\]</div>
<p>and you should recognize <span class="math notranslate nohighlight">\(\left(p \boldsymbol{I} -\mu \nabla \boldsymbol{u} \right)\cdot \boldsymbol{n}\)</span> as part of the total stress <span class="math notranslate nohighlight">\(\tau=-p \boldsymbol{I}+\mu(\nabla \boldsymbol{u} + \nabla  \boldsymbol{u}^T)\)</span> acting on the surface with normal vector <span class="math notranslate nohighlight">\(\boldsymbol{n}\)</span>. In finite element communities the boundary condition <span class="math notranslate nohighlight">\(\left(p \boldsymbol{I} -\mu \nabla \boldsymbol{u} \right) \cdot \boldsymbol{n}=0\)</span> is called pseudo-traction or a do-nothing boundary condition. It is often used on outlets where we are simply interested in letting the fluid escape with as little interference of boundary conditions as possible. It is called do-noting because you donât have to do anything to enforce it, just simply omit the boundary terms and solve the two equations</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \mu \int_{\Omega} \nabla \boldsymbol{v} : \nabla \boldsymbol{u}\, \mathrm{d}x -\int_{\Omega} p\, \nabla \cdot \boldsymbol{v} \, \mathrm{d}x &amp;= 0, \\
  \int_{\Omega} q\,  {\nabla} \cdot \boldsymbol{u} \,\mathrm{d}x &amp;= 0.
\end{aligned}\end{split}\]</div>
<p>In FEniCS we may set up these two equations (one vector and one scalar equation) to be solved in a coupled manner. The approach is given below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitSquareMesh</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

<span class="c1"># Build function space</span>
<span class="n">P2</span> <span class="o">=</span> <span class="n">VectorElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">P1</span> <span class="o">=</span> <span class="n">FiniteElement</span><span class="p">(</span><span class="s2">&quot;CG&quot;</span><span class="p">,</span> <span class="n">mesh</span><span class="o">.</span><span class="n">ufl_cell</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">TH</span> <span class="o">=</span> <span class="n">P2</span> <span class="o">*</span> <span class="n">P1</span>
<span class="n">VQ</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">TH</span><span class="p">)</span>
<span class="n">u</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">TrialFunctions</span><span class="p">(</span><span class="n">VQ</span><span class="p">)</span>
<span class="n">v</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">TestFunctions</span><span class="p">(</span><span class="n">VQ</span><span class="p">)</span>

<span class="n">mu</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">mu</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">div</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">-</span> <span class="n">inner</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">div</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
</div>
</div>
<p>Note that terms involving <code class="docutils literal notranslate"><span class="pre">TestFunction</span> <span class="pre">v</span></code> end up in the vector equation, whereas terms containing <code class="docutils literal notranslate"><span class="pre">TestFunction</span> <span class="pre">q</span></code> end up in the scalar equation. All terms defined in F are bilinear, in that they all contain one <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code> and one <code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code>. The sign of the velocity divergence has been set to negative, because this leads to a symmetric coefficient matrix, which is favorable for iterative solvers (even though we are not using a iterative solver here).</p>
<p>To solve the equations we need to create a <code class="docutils literal notranslate"><span class="pre">Function</span></code> in the mixed functionspace to hold the solution, for example like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">up_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">VQ</span><span class="p">)</span>
<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">VQ</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Expression</span><span class="p">((</span><span class="s2">&quot;x[0]*(1-x[0])&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span> <span class="n">degree</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;std::abs(x[1])&gt;1-1e-12 &amp;&amp; on_boundary&quot;</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">VQ</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">Constant</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="s2">&quot;std::abs(x[0]*(1-x[0])*x[1])&lt;1e-12 &amp;&amp; on_boundary&quot;</span><span class="p">)</span>
<span class="n">solve</span><span class="p">(</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">up_</span><span class="p">,</span> <span class="n">bcs</span><span class="o">=</span><span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">])</span>
<span class="n">u_</span><span class="p">,</span> <span class="n">p_</span> <span class="o">=</span> <span class="n">up_</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="n">plot</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
</div>
</div>
<p>The boundary conditions will of course depend on the problem being solved. Here we have set homogeneous Dirichlet (no-slip) on three walls and a parabolic profile on top, which corresponds to a modified lid driven cavity.
Note that boundary conditions for velocity are set using <code class="docutils literal notranslate"><span class="pre">VQ.sub(0)</span></code>, where <code class="docutils literal notranslate"><span class="pre">sub(0)</span></code> corresponds to subspace 0 of the mixed <code class="docutils literal notranslate"><span class="pre">VQ</span></code> space. A Dirichlet boundary condition on pressure could have been set using <code class="docutils literal notranslate"><span class="pre">VQ.sub(1)</span></code>, but here that would be an over-specification.</p>
<p>The stream function <span class="math notranslate nohighlight">\(\psi(\boldsymbol{x}, t)\)</span> was defined in Eq. <a class="reference internal" href="content/intro.html#equation-eq-streamfunction2d">(33)</a> in <span class="xref myst">Similarity solutions</span>. The Poisson equation <a class="reference internal" href="content/intro.html#equation-eq-eqstreamfunction2d">(34)</a> (in <span class="xref myst">Similarity solutions</span>) for the streamfunction, can be transformed to a variational form by multiplying with a <code class="docutils literal notranslate"><span class="pre">TestFunction</span></code> <span class="math notranslate nohighlight">\(\psi_v\)</span> and then integrating over the domain using integration by parts</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \int_{\Omega} \psi_v \nabla^2 \psi \mathrm{d} x &amp;= -\int_{\Omega} \psi_v \omega_z \mathrm{d}x, \notag \\
  -\int_{\Omega} \nabla (\psi_v) \cdot \nabla (\psi) \mathrm{d}x + \int_{\Gamma} \psi_v \nabla \psi \cdot \boldsymbol{n} \mathrm{d}s &amp;= -\int_{\Omega} \psi_v \omega_z \mathrm{d}x. \label{eq:FormStreamfunction}
\end{aligned}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{n}\)</span> is the normal vector pointing outwards from the external boundary. The normal can be used directly in FEniCS forms through, e.g., <code class="docutils literal notranslate"><span class="pre">n=FacetNormal(mesh)</span></code>.</p>
<p>By taking the curl of the momentum equation <a class="reference internal" href="#equation-eq-stokes">(44)</a> and using that the curl of a gradient is always zero, an equation for the vorticity vector <span class="math notranslate nohighlight">\(\boldsymbol{\omega}\)</span> is obtained</p>
<div class="math notranslate nohighlight">
\[  \nabla^2 \boldsymbol{\omega} = 0.\]</div>
<p>Likewise, by taking the divergence (not gradient as it says in White <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>) of the momentum equation <a class="reference internal" href="#equation-eq-stokes">(44)</a> we obtain an equation for the pressure</p>
<div class="math notranslate nohighlight">
\[  \nabla^2 p = 0,\]</div>
<p>which follows since <span class="math notranslate nohighlight">\(\nabla \cdot \nabla^2 \boldsymbol{u} = \nabla^2 (\nabla \cdot \boldsymbol{u})=0\)</span>. For Stokes flow both the pressure and the vorticity are governed by homogeneous Laplace equations. For 2D flows we also know the equation for the streamfunction <span class="math notranslate nohighlight">\(\nabla^2 \psi = -\omega_z\)</span>. Inserting this into the Laplace equation for <span class="math notranslate nohighlight">\(\omega_z\)</span> we obtain</p>
<div class="math notranslate nohighlight">
\[  \nabla^4 \psi = 0,\]</div>
<p>which is a biharmonic equation for the streamfunction. Obviously, if <span class="math notranslate nohighlight">\(\psi\)</span> is a solution to <span class="math notranslate nohighlight">\(\nabla^4 \psi = 0\)</span>, then <span class="math notranslate nohighlight">\(-\psi\)</span> is a solution as well. In other words, the direction of flow along a streamline is arbitrary and only fixed due to boundary conditions. Reversing the direction of the flow (like we do in the mandatory assignment) will not change the streamlines, but the values will get the opposite sign.</p>
<p>Stokes paradox states that it is not possible to obtain steady solutions to <span class="math notranslate nohighlight">\(\nabla^4 \psi = 0\)</span> for 2D flows with both free stream and no-slip boundary conditions. Stokes paradox is, like dâAlembertâs
paradox, really only a paradox because the equations do not represent real physical flow, just approximations in the limit. It follows from Stokes paradox that inertia can never be neglected for 2D flows with both free stream and no-slip boundary conditions.</p>
<div class="section" id="creeping-flow-past-a-sphere">
<h4>Creeping flow past a sphere<a class="headerlink" href="#creeping-flow-past-a-sphere" title="Permalink to this headline">Â¶</a></h4>
<p>Stokes flow past a sphere of radius <span class="math notranslate nohighlight">\(a\)</span> is a 3D flow and thus solutions to <span class="math notranslate nohighlight">\(\nabla^4 \psi = 0\)</span> may be found even though there is no-slip on the sphere wall and free stream far away. In spherical polar coordinates the stream function, <span class="math notranslate nohighlight">\(\psi\)</span>, is defined through</p>
<div class="math notranslate nohighlight" id="equation-eq-streamfunctionsphere">
<span class="eqno">(45)<a class="headerlink" href="#equation-eq-streamfunctionsphere" title="Permalink to this equation">Â¶</a></span>\[  u_r = \frac{1}{r^2 \sin \theta} \frac{\partial \psi}{\partial \theta}, \quad u_{\theta} = -\frac{1}{r \sin \theta} \frac{\partial \psi}{\partial r}. \]</div>
<p>The streamfunction equation becomes for spherical coordinates</p>
<div class="math notranslate nohighlight">
\[ \left( \frac{\partial^2 }{\partial r^2} + \frac{1}{r} \frac{\partial^2 }{\partial \theta^2} - \frac{\cot \theta}{r^2} \frac{\partial}{\partial \theta} \right)^2 \psi = 0,\]</div>
<p>with boundary conditions</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial \psi}{\partial r} &amp;=  \frac{\partial \psi}{\partial \theta} = 0, \quad \text{for}\quad r=a, \\
  \psi &amp;= \frac{1}{2} U r^2 \sin^2 \theta + \text{const}, \quad \text{for} \quad r \longleftrightarrow \infty.
\end{aligned}\end{split}\]</div>
<p>Using separation of variables White reports that the solution to this problem reads</p>
<div class="math notranslate nohighlight">
\[  \psi = \frac{1}{4}U a^2 \sin ^2 \theta \left(\frac{a}{r} - \frac{3r}{a} + \frac{2r^2}{a^2}\right),\]</div>
<p>and thus we obtain the velocity components from <a class="reference internal" href="#equation-eq-streamfunctionsphere">(45)</a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  u_r &amp;= U \cos \theta  \left(1 + \frac{a^3}{2r^3} - \frac{3a}{2r}\right), \\
  u_{\theta} &amp;= U \sin \theta \left(-1 + \frac{a^3}{4r^3} + \frac{3a}{4r}\right)
\end{aligned}\end{split}\]</div>
<p>A few important notes</p>
<ul class="simple">
<li><p>The velocity is independent of <span class="math notranslate nohighlight">\(\rho\)</span> and <span class="math notranslate nohighlight">\(\mu\)</span>, which is actually true for all creeping flows.</p></li>
<li><p>There is perfect symmetry of the streamlines past the sphere. No wake and no separation.</p></li>
<li><p>The velocity is everywhere smaller than the free stream. This is contrary to inviscid flows where the velocity is maximum at the top and bottom of the sphere. For Stokes flow the velocity will here be zero due to no-slip.</p></li>
<li><p>The effect of the sphere can be observed at enormous distances away from the sphere. At <span class="math notranslate nohighlight">\(r=10a\)</span> the velocity is still <span class="math notranslate nohighlight">\(10 \%\)</span> lower  than the free stream.</p></li>
</ul>
<p>The pressure can be computed from the momentum equations in radial and <span class="math notranslate nohighlight">\(\theta\)</span>-direction</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial p}{\partial r} &amp;= \mu \left( \nabla^2 u_r - \frac{2 u_r}{r^2} - \frac{2}{r^2}\frac{\partial u_{\theta}}{\partial \theta} - \frac{2 u_{\theta} \cot \theta}{r^2} \right), \\
  \frac{\partial p}{\partial \theta} &amp;= \mu r \left( \nabla^2 u_{\theta} + \frac{2}{r^2}\frac{\partial u_r}{\partial \theta} - \frac{u_{\theta}}{r^2 \sin^2 \theta} \right)
\end{aligned}\end{split}\]</div>
<p>Insert for <span class="math notranslate nohighlight">\(u_r\)</span> and <span class="math notranslate nohighlight">\(u_{\theta}\)</span> and integrate both equations, using boundary conditions, to obtain</p>
<div class="math notranslate nohighlight" id="equation-eq-pressuresphere">
<span class="eqno">(46)<a class="headerlink" href="#equation-eq-pressuresphere" title="Permalink to this equation">Â¶</a></span>\[  p(r, \theta) = p_{\infty} - \frac{3 \mu a U}{2 r^2} \cos \theta,\]</div>
<p>where <span class="math notranslate nohighlight">\(p_{\infty}\)</span> is the pressure in the free stream. From <a class="reference internal" href="#equation-eq-pressuresphere">(46)</a> it is evident that the pressure is highest at the front (left hand side) of the sphere where <span class="math notranslate nohighlight">\(\theta=\pi\)</span>, and lowest at the rear where <span class="math notranslate nohighlight">\(\theta=0\)</span>. The pressure difference sets up a force acting on the sphere in the streamwise direction. The total force acting on the sphere is a vector that can be computed as</p>
<div class="math notranslate nohighlight">
\[  \boldsymbol{F} = \int_{\Gamma} \tau \cdot \boldsymbol{n}\, \mathrm{d}A,\]</div>
<p>where as before the total stress is composed of pressure and friction  through the stress tensor <span class="math notranslate nohighlight">\(\tau=-p \boldsymbol{I}+\mu(\nabla \boldsymbol{u}+\nabla \boldsymbol{u}^T)\)</span>. The normal to the surface of the sphere is everywhere aligned with the <span class="math notranslate nohighlight">\(r\)</span>-direction such that we can write</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \boldsymbol{F_p} + \boldsymbol{F_{\tau}} &amp;= \int_{\Gamma} \left(-p \boldsymbol{I} +\mu  (\nabla  \boldsymbol{u} + \nabla  \boldsymbol{u}^T) \right) \cdot \boldsymbol{n}\, \mathrm{d}A, \\
  &amp;= \int_{0}^{\pi} (\tau_{rr} + \tau_{r\theta})2\pi a^2 \sin \theta \mathrm{d} \theta,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\tau_{rr}\)</span> and <span class="math notranslate nohighlight">\(\tau_{r\theta}\)</span> are the pressure and friction stresses respectively. This follows since the pressure force is always acting normal to the plane and shear acts in the tangent plane. Remember that <span class="math notranslate nohighlight">\(\tau_{ij}\)</span> is a force acting in the <span class="math notranslate nohighlight">\(j\)</span>-direction on a plane having <span class="math notranslate nohighlight">\(i\)</span> as the normal direction.</p>
<p>The pressure has already been computed. The remaining shear stress can be computed in spherical coordinates as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \tau_{r\theta} &amp;= \mu \left( \frac{1}{r} \frac{\partial u_r}{\partial \theta} + \frac{\partial u_{\theta}}{\partial r} - \frac{u_{\theta}}{r} \right), \\
  &amp;= -\frac{\mu U \sin \theta}{r} \frac{3 a^3}{2 r^3}.
\end{aligned}\end{split}\]</div>
<p>The total force acting in the streamwise direction is computed by inserting for <span class="math notranslate nohighlight">\(\tau_{rr}\)</span> and <span class="math notranslate nohighlight">\(\tau_{r\theta}\)</span> leading to two simple integral as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  F_{x} &amp;= |\boldsymbol{F_p}| \cos \theta + |\boldsymbol{F_{\tau}}| \sin \theta \\
        &amp;= 3 \mu U \pi a \left(\frac{2}{3} + \frac{4}{3} \right), \\
        &amp;= 6 \mu \pi U a.
\end{aligned}\end{split}\]</div>
<p>In other words, the drag force consists of 2/3 friction and 1/3 pressure.</p>
<p id="bibtex-bibliography-content/chapter3/stokes-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets"><a class="fn-backref" href="#id1">Whi06</a></span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>
</div>
<span id="document-content/chapter4/intro"></span><div class="section" id="chapter-4">
<h2>Chapter 4<a class="headerlink" href="#chapter-4" title="Permalink to this headline">Â¶</a></h2>
<p>Important topics of Chapter 4 <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>.</p>
<ol class="simple">
<li><p>Displacement thickness</p></li>
<li><p>Momentum thickness</p></li>
<li><p>Flat plate integral analysis</p></li>
<li><p>Boundary layer equations</p></li>
<li><p>Flow separation</p></li>
<li><p>Blasius solution</p></li>
<li><p>Falkner-Skan solution</p></li>
</ol>
<div class="section" id="suggested-assignments-chapter-4">
<h3>Suggested assignments chapter 4<a class="headerlink" href="#suggested-assignments-chapter-4" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="written-assignments-chapter-4">
<h4>Written assignments chapter 4<a class="headerlink" href="#written-assignments-chapter-4" title="Permalink to this headline">Â¶</a></h4>
<ol class="simple">
<li><p>Derive the boundary layer equations (Eq. (4-32) in <a class="bibtex reference internal" href="content/intro.html#white06" id="id2">[Whi06]</a>) starting from the Navier-Stokes equations.</p></li>
<li><p>Derive the Blasius equation.</p></li>
<li><p>Derive the Falkner-Skan equation.</p></li>
</ol>
</div>
<div class="section" id="computer-assignments-chapter-4">
<h4>Computer assignments chapter 4<a class="headerlink" href="#computer-assignments-chapter-4" title="Permalink to this headline">Â¶</a></h4>
<ol class="simple">
<li><p>Implement a nonlinear solver for the Blasius equation. Do the same for the Falkner-Skan equation and vary the parameter <span class="math notranslate nohighlight">\(\beta\)</span> as shown in Fig. 4-11 in <a class="bibtex reference internal" href="content/intro.html#white06" id="id3">[Whi06]</a>. What happens at <span class="math notranslate nohighlight">\(\beta=-0.19884\)</span>? At <span class="math notranslate nohighlight">\(-0.19884 \leq \beta \leq 0\)</span> there are according to White at least two possible solutions. One solution is shown in Fig. 4-11a in White. Another solution shows negative values for <span class="math notranslate nohighlight">\(f^{\prime \prime}(0)\)</span>, thus indicating backflow close to the wall. Using different initial guesses for the solution it should be possible to obtain both solutions.</p></li>
<li><p>Compute the flow past a rotating cylinder. Use a rectangular domain <span class="math notranslate nohighlight">\(\Omega = [0, 6] \times [-1, 1]\)</span> and place the cylinder at <span class="math notranslate nohighlight">\((x,y) = (1,0)\)</span> with a radius of 0.25. Assume at first steady creeping flow, walls at <span class="math notranslate nohighlight">\(y = \pm 1\)</span> and set the velocity on the left hand side (<span class="math notranslate nohighlight">\(x=0\)</span>) to <span class="math notranslate nohighlight">\(1-y^2\)</span>. Set the cylinder to rotate against the clock at a constant speed of 1. Compute lift and drag forces on the cylinder. Reverse the direction of the rotation and recompute lift and drag. Now include convection and solve the Steady (nonlinear) Navier-Stokes equations for the same problem. Set the rotation to oscillate with an angular speed of <span class="math notranslate nohighlight">\(\sin \pi t\)</span> and compute the unsteady creeping flow past the cylinder. Do the same for unsteady Navier-Stokes and attempt to find the <a class="reference external" href="https://en.wikipedia.org/wiki/K%C3%A1rm%C3%A1n_vortex_street">von KÃ¡rmÃ¡n street</a> for a steady cylinder.</p></li>
</ol>
<p id="bibtex-bibliography-content/chapter4/intro-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets">Whi06</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>)</span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>
<span id="document-content/chapter6/turbulence"></span><div class="section" id="chapter-6">
<h2>Chapter 6<a class="headerlink" href="#chapter-6" title="Permalink to this headline">Â¶</a></h2>
<div class="section" id="incompressible-turbulent-mean-flow">
<h3>Incompressible turbulent mean flow<a class="headerlink" href="#incompressible-turbulent-mean-flow" title="Permalink to this headline">Â¶</a></h3>
<p>Turbulent flows are governed by the Navier-Stokes equations. However,</p>
<ul class="simple">
<li><p>there are no simplifications possible by dimensional analysis or through similarity solutions,</p></li>
<li><p>no exact definition is known for turbulence,</p></li>
<li><p>turbulent flows are not very well understood.</p></li>
</ul>
<p>Turbulent flows are usually <em>defined</em> by listing their most characteristic properties. Here is what we know</p>
<ul>
<li><p>Turbulence is a <em>flow</em> property and not a <em>fluid</em> property.</p></li>
<li><p>Turbulence is always three-dimensional in space and transient. There is no such thing as two-dimensional turbulence.</p></li>
<li><p>Turbulence is irregular, with seemingly random and chaotic motion. However, there is order to the chaos. The flow satisfies the Navier-Stokes equations, so it is apparently deterministic. Still, N-S are extremely sensitive to initial and boundary conditions (the butterfly-effect). The slightest perturbations in initial or boundary conditions leads to a completely different solution. Thus, <em>turbulence is stochastic even though the Navier-Stokes equations are deterministic</em>.</p></li>
<li><p>Turbulent flows consist to a great deal of vortices and vorticity. Vortex stretching and tilting are 3-dimensional phenomena that characterize turbulent flows and these processes can not happen in 2D. If a vortex tube is stretched it must increase its angular velocity to conserve angular momentum. This can only happen in 3D. In 2D vorticity is (unphysically) a conserved quantity.</p></li>
<li><p>The vortices come in a range of scales. The size of the largest vortices (the largest scales) is determined by the geometry of the flow, whereas the size of the smallest vortices (the smallest scales) is determined by viscosity.</p></li>
<li><p>The energy cascade. Energy is introduced into the flow on the largest scales and dissipated on the smallest. Dissipation <span class="math notranslate nohighlight">\(\varepsilon\)</span> of kinetic energy is defined as</p>
<div class="math notranslate nohighlight">
\[
   \varepsilon = \mu \boldsymbol{s} : \boldsymbol{s}, \quad {\mathrm{where\,\, strain }}\quad \boldsymbol{s} = 0.5\left( \nabla \boldsymbol{u} + \nabla \boldsymbol{u}^T \right)
   \]</div>
<p>The strain increases dramatically towards the center of a vortex tube leading to higher dissipation rates in this region.</p>
</li>
<li><p>Turbulence occur at high Reynolds numbers. The normalized  momentum equation reads</p>
<div class="math notranslate nohighlight">
\[
   \frac{\partial \boldsymbol{u}}{\partial t} + (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} = -\nabla p + \frac{1}{Re} \nabla ^2 \boldsymbol{u} + \boldsymbol{f}.
   \]</div>
<p>Diffusion is stabilizing as it tends to smear out all gradients. Briefly, perturbations (disturbances) to the flow are amplified by convection and dampened by viscosity. If the Reynolds number is large, then diffusion is small and convection dominates, leading to unstable turbulent flows. If the Reynolds number is small then viscosity dominates and perturbations are killed before they can trigger turbulence.</p>
</li>
</ul>
<div class="figure align-default" id="turbvel">
<a class="reference internal image-reference" href="../_images/turb_vel.png"><img alt="../_images/turb_vel.png" src="../_images/turb_vel.png" style="width: 300px; height: 200px;" /></a>
<p class="caption"><span class="caption-number">Fig. 5 </span><span class="caption-text">Figure shows 1000 instantaneous measurements of one chaotic velocity component.</span><a class="headerlink" href="#turbvel" title="Permalink to this image">Â¶</a></p>
</div>
<p>Engineers need to be able to predict the behaviour of turbulent flows. However, in a turbulent flow the velocity <span class="math notranslate nohighlight">\(\boldsymbol{u}(\boldsymbol{x}, t)\)</span> and pressure <span class="math notranslate nohighlight">\(p(\boldsymbol{x}, t)\)</span> should really be considered as random variables. In other words, at any point in space and time we will not be able to predict the exact value of velocity or pressure. We can, however, predict the statistical properties of these random variables. This is usually accomplished using ensemble averages or <em>Reynolds averaging</em>.</p>
<p>Consider first a turbulent flow that is statistically steady, i.e., the statistical properties of the flow are independent of time. This happens, e.g., for a plane channel flow or a straight pipe flow where the applied pressure gradient (the driving force) is held constant.
As previously stated, in a turbulent flow the velocity vector <span class="math notranslate nohighlight">\(\boldsymbol{u}(\boldsymbol{x}, t)\)</span> can be considered a random variable. If you stand in the same spot inside the statistically steady turbulent flow and measure one velocity component, then the signal will look a lot like Gaussian noise, as can be seen in <a class="reference internal" href="#turbvel"><span class="std std-numref">Fig. 5</span></a>.</p>
<p>The <em>arithmetic</em> mean of the velocity over these samples can computed as</p>
<div class="math notranslate nohighlight">
\[  \left&lt;u\right&gt;(\boldsymbol{x}) = \frac{1}{N} \sum_{i=1}^N u(\boldsymbol{x}, t_i)\]</div>
<p>where <span class="math notranslate nohighlight">\(u(\boldsymbol{x}, t_i)\)</span> is the velocity at time <span class="math notranslate nohighlight">\(t_i\)</span> and <span class="math notranslate nohighlight">\(N=1000\)</span> for the turbulent series shown. If the sampling is done in discrete intervals of time <span class="math notranslate nohighlight">\(\triangle t\)</span>, then <span class="math notranslate nohighlight">\(t_i = i\triangle t\)</span>. Furthermore, if the samples are taken at sufficiently long time intervals such that <span class="math notranslate nohighlight">\(u(\boldsymbol{x}, t_i)\)</span> is uncorrelated with <span class="math notranslate nohighlight">\(u(\boldsymbol{x}, t_i+\triangle t)\)</span> then we talk about an <em>ensemble</em> average as</p>
<div class="math notranslate nohighlight">
\[  \overline{u}(\boldsymbol{x}) = \lim_{N\rightarrow \infty} \frac{1}{N} \sum_{i=1}^N u(\boldsymbol{x}, t_i).\]</div>
<p>By multiplying through by <span class="math notranslate nohighlight">\(\triangle t\)</span> in both numerator and denominator the ensemble average can also be rewritten as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \overline{u}(\boldsymbol{x}) &amp;= \lim_{N\rightarrow \infty} \frac{1}{N\triangle t} \sum_{i=1}^N u(\boldsymbol{x}, t_i) \triangle t, \\
   &amp;\approx \frac{1}{T} \int_0^{T} u(\boldsymbol{x}, t) \mathrm{d} t,
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(T=N\triangle t\)</span> is the total sampling time, which typically needs to be larger than the largest timescales of the flow. It can be seen that for a statistically steady flow the ensemble average corresponds to the time average.</p>
<p>For a more general turbulent flow where the statistics can change in time more care needs to be taken in defining the ensemble average because the random variable <span class="math notranslate nohighlight">\({u}(\boldsymbol{x}, t)\)</span> will in general be statistically different from the random variable <span class="math notranslate nohighlight">\({u}(\boldsymbol{x}, t+\triangle t)\)</span> (e.g., <span class="math notranslate nohighlight">\(\overline{u}(\boldsymbol{x}, t) \neq \overline{u}(\boldsymbol{x}, t+\triangle t)\)</span>). To resolve this, consider flipping a coin. If <span class="math notranslate nohighlight">\(\xi\)</span> is the random variable where head gives <span class="math notranslate nohighlight">\(\xi=1\)</span> and tail <span class="math notranslate nohighlight">\(\xi=0\)</span>, then the arithmetic average obviously become</p>
<div class="math notranslate nohighlight">
\[ \left&lt; \xi\right&gt; = \frac{1}{N}\sum_{i=1}^N \xi^{(i)}\]</div>
<p>where <span class="math notranslate nohighlight">\(\xi^{(i)}\)</span> is the result of flip <span class="math notranslate nohighlight">\(i\)</span> and as <span class="math notranslate nohighlight">\(N\rightarrow \infty\)</span> we should get <span class="math notranslate nohighlight">\(\left&lt; \xi\right&gt; = 0.5\)</span>.
Now, if the coins are identical then the arithmetic average is obviously the same if one person flips a coin <span class="math notranslate nohighlight">\(N\)</span> times or <span class="math notranslate nohighlight">\(N\)</span> persons flip one coin one time. This principle is used in defining an ensemble average for turbulent flows. If, instead of sampling the random variable <span class="math notranslate nohighlight">\(u(\boldsymbol{x}, t)\)</span> at <span class="math notranslate nohighlight">\(N\)</span> different time intervals, we run <span class="math notranslate nohighlight">\(N\)</span> identical experiments and sample <span class="math notranslate nohighlight">\(u(\boldsymbol{x}, t)\)</span> at the same time and place in all experiments, then the definition of the ensemble average will be</p>
<div class="math notranslate nohighlight">
\[  \overline{u}(\boldsymbol{x}, t) = \lim_{N\rightarrow \infty} \frac{1}{N} \sum_{i=1}^N u^{(i)}(\boldsymbol{x}, t).\]</div>
<p>For a statistically steady flow this will be identical to the time average and the left hand side will not  be dependent on time.</p>
<p>By using the ensemble average the instantaneous velocity and pressure may be decomposed into a mean and fluctuating component</p>
<div class="math notranslate nohighlight" id="equation-eq-reynoldsaverage">
<span class="eqno">(47)<a class="headerlink" href="#equation-eq-reynoldsaverage" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
  \boldsymbol{u}(\boldsymbol{x}, t) &amp;= \overline{\boldsymbol{u}}(\boldsymbol{x}, t) + \boldsymbol{u}'(\boldsymbol{x}, t), \notag \\
  p(\boldsymbol{x}, t) &amp;= \overline{p}(\boldsymbol{x}, t) + p'(\boldsymbol{x}, t).
\end{aligned}\end{split}\]</div>
<p>Note that both the instantaneous velocity <span class="math notranslate nohighlight">\(\boldsymbol{u}(\boldsymbol{x}, t)\)</span> and the fluctuating velocity <span class="math notranslate nohighlight">\(\boldsymbol{u}'(\boldsymbol{x}, t)\)</span> should be considered as random variables, whereas the mean velocity <span class="math notranslate nohighlight">\(\overline{\boldsymbol{u}}(\boldsymbol{x}, t)\)</span> is deterministic. Consider any random variable decomposed as <span class="math notranslate nohighlight">\(\phi = \overline{\phi} + \phi'\)</span>. By definition we have <span class="math notranslate nohighlight">\(\overline{\phi'}=0\)</span>. This follows since we can take the average of both sides of Eq. <a class="reference internal" href="#equation-eq-reynoldsaverage">(47)</a> leading to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \overline{\phi} &amp;= \overline{\overline{\phi} + \phi'},\\
                 &amp;= \overline{\overline{\phi}} + \overline{\phi'}, \\
                 &amp;= \overline{\phi} + \overline{\phi'},
\end{aligned}\end{split}\]</div>
<p>that can only be true if <span class="math notranslate nohighlight">\(\overline{\phi'}=0\)</span>. (Note that the average of an average is still the average.) Some other useful averaging rules are</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \overline{\phi' \overline{\phi}} &amp;= \overline{\phi'}\, \overline{\phi} = 0,\\
  \overline{\phi \overline{\phi}} &amp;= \overline{\phi}\, \overline{\phi}, \\
  \overline{\phi \phi} &amp;= \overline{(\overline{\phi} + \phi')(\overline{\phi} + \phi')} = \overline{\phi}^2 + \overline{\phi'\phi'}, \\
  \overline{\frac{\partial \phi}{\partial s}} &amp;= \frac{\partial \overline{\phi}}{\partial s}.
\end{aligned}\end{split}\]</div>
<p>The last rule follows since the two operations differentiation and averaging <em>commute</em>, i.e., the derivative of an average is the same as the average of a derivative.</p>
</div>
<div class="section" id="derivation-of-reynolds-averaged-navier-stokes-rans-equations">
<h3>Derivation of Reynolds averaged Navier-Stokes (RANS) equations<a class="headerlink" href="#derivation-of-reynolds-averaged-navier-stokes-rans-equations" title="Permalink to this headline">Â¶</a></h3>
<p>Having defined the average velocity and pressure we are now in a need of equations that can be used to predict them. Equations for any statistical measure can be derived directly by manipulating the Navier-Stokes equations. The equations for <span class="math notranslate nohighlight">\(\overline{\boldsymbol{u}}\)</span> and <span class="math notranslate nohighlight">\(\overline{p}\)</span> are found simply by averaging NS and introducing Eq. <a class="reference internal" href="#equation-eq-reynoldsaverage">(47)</a>. Averaging the continuity equation leads to</p>
<div class="math notranslate nohighlight">
\[ \overline{\nabla \cdot \boldsymbol{u}} = \nabla \cdot \overline{\boldsymbol{u}} = 0\]</div>
<p>simply because averaging and differentiation commutes. The average of the momentum equation can be written</p>
<div class="math notranslate nohighlight">
\[  \overline{\frac{\partial \boldsymbol{u}}{\partial t} + (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} = -\frac{1}{\rho}\nabla p + \nu \nabla ^2 \boldsymbol{u} + \boldsymbol{f}}\]</div>
<p>The density and viscosity are assumed constant. The first term on the left and all terms on the right are averaged by using commutation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \overline{\frac{\partial \boldsymbol{u}}{\partial t}} &amp;= \frac{\partial \overline{\boldsymbol{u}}}{\partial t}, \\
  \overline{\frac{1}{\rho}\nabla p} &amp;= \frac{1}{\rho}\nabla \overline{p}, \\
  \overline{\nu \nabla ^2 \boldsymbol{u}} &amp;= \nu \nabla ^2 \overline{\boldsymbol{u}}.
\end{aligned}\end{split}\]</div>
<p>This leaves the nonlinear convection term. Using index notation we can take two fast steps using continuity and commutation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \overline{u_j \frac{\partial u_i}{\partial x_j}} &amp;= \overline{ \frac{\partial u_i u_j}{\partial x_j}} - \cancel{\overline{u_i \frac{\partial u_j}{\partial x_j}}}  \\
 &amp;= \frac{\partial \overline{u_i u_j}}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>Inserting now for Eq. <a class="reference internal" href="#equation-eq-reynoldsaverage">(47)</a> we have</p>
<div class="math notranslate nohighlight">
\[ \overline{u_i u_j} = \overline{(\overline{u}_i + u_i')(\overline{u}_j + u_j')} = \overline{u}_i \overline{u}_j + \overline{u_i' u_j'}\]</div>
<p>and thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \overline{u_j \frac{\partial u_i}{\partial x_j}} &amp;= \frac{\partial \overline{u}_i \overline{u}_j +  \overline{u_i' u_j'}}{\partial x_j} \\
 &amp;= \overline{u}_j \frac{\partial \overline{u}_i}{\partial x_j} + \frac{\partial \overline{u_i' u_j'}}{\partial x_j}
\end{aligned}\end{split}\]</div>
<p>Putting it all together we obtain the Reynolds averaged Navier-Stokes equations</p>
<div class="math notranslate nohighlight" id="equation-eq-rans">
<span class="eqno">(48)<a class="headerlink" href="#equation-eq-rans" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial \overline{\boldsymbol{u}}}{\partial t} + (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}} = -\frac{1}{\rho}\nabla \overline{p} + \nu \nabla ^2 \overline{\boldsymbol{u}} - \frac{\partial \overline{u_i' u_j'}}{\partial x_j} + \overline{\boldsymbol{f}},\]</div>
<div class="math notranslate nohighlight" id="equation-eq-ranscont">
<span class="eqno">(49)<a class="headerlink" href="#equation-eq-ranscont" title="Permalink to this equation">Â¶</a></span>\[  \nabla \cdot \overline{\boldsymbol{u}} = 0\]</div>
</div>
<div class="section" id="derivation-of-equation-for-average-turbulent-kinetic-energy">
<h3>Derivation of equation for average turbulent kinetic energy<a class="headerlink" href="#derivation-of-equation-for-average-turbulent-kinetic-energy" title="Permalink to this headline">Â¶</a></h3>
<p>The Reynolds averaged Navier-Stokes equations are derived in the previous section. To derive the turbulent kinetic energy equation it can be advantageous to first derive an equation for the fluctuating velocity <span class="math notranslate nohighlight">\(\boldsymbol{u}'\)</span>. Such an equation can be derived by subtracting
Eq. <a class="reference internal" href="#equation-eq-rans">(48)</a> from the instantaneous momentum equation. All terms are trivial except from the convection</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \frac{\partial \boldsymbol{u} - \overline{\boldsymbol{u}}}{\partial t} + (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} - (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}} &amp;= -\frac{1}{\rho}\nabla (p- \overline{p}) + \nu \nabla ^2 (\boldsymbol{u} - \overline{\boldsymbol{u}}) +\frac{\partial \overline{u_i' u_j'}}{\partial x_j} + \boldsymbol{f} - \overline{\boldsymbol{f}}, \\
  \frac{\partial \boldsymbol{u}'}{\partial t} + (\boldsymbol{u} \cdot \nabla)\boldsymbol{u} - (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}} &amp;= -\frac{1}{\rho}\nabla p' + \nu \nabla ^2 \boldsymbol{u}' +\frac{\partial \overline{u_i' u_j'}}{\partial x_j} + \boldsymbol{f}'  .
\end{aligned}\end{split}\]</div>
<p>The convection terms are manipulated by inserting for <span class="math notranslate nohighlight">\(\boldsymbol{u}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
(\boldsymbol{u} \cdot \nabla)\boldsymbol{u} - (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}} &amp;= ((\overline{\boldsymbol{u}}+\boldsymbol{u}') \cdot \nabla)(\overline{\boldsymbol{u}}+\boldsymbol{u}') - (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}}, \\
 &amp;= (\overline{\boldsymbol{u}} \cdot \nabla) \boldsymbol{u}' +  (\boldsymbol{u}' \cdot \nabla) (\overline{\boldsymbol{u}}+\boldsymbol{u}' ),
\end{aligned}\end{split}\]</div>
<p>which gives us the final equation for the fluctuating velocity component</p>
<div class="math notranslate nohighlight" id="equation-eq-fluctvel">
<span class="eqno">(50)<a class="headerlink" href="#equation-eq-fluctvel" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial \boldsymbol{u}'}{\partial t} + (\overline{\boldsymbol{u}} \cdot \nabla) \boldsymbol{u}' = -\frac{1}{\rho}\nabla p' + \nu \nabla ^2 \boldsymbol{u}' - (\boldsymbol{u}' \cdot \nabla) (\overline{\boldsymbol{u}}+\boldsymbol{u}' ) +\frac{\partial \overline{u_i' u_j'}}{\partial x_j} + \boldsymbol{f}'.\]</div>
<p>Using index notation throughout the equation reads</p>
<div class="math notranslate nohighlight" id="equation-eq-fluctvelindex">
<span class="eqno">(51)<a class="headerlink" href="#equation-eq-fluctvelindex" title="Permalink to this equation">Â¶</a></span>\[  \frac{\partial u_i'}{\partial t} + \overline{u}_j \frac{\partial u_i'}{\partial x_j} = -\frac{1}{\rho}\frac{\partial p'}{\partial x_i} + \nu \frac{\partial^2 u_i'}{\partial x_j \partial x_j} - u_j'\frac{\partial \overline{u}_i}{\partial x_j} - u_j'\frac{\partial u_i'}{\partial x_j} +\frac{\partial \overline{u_i' u_j'}}{\partial x_j} + f_i'.\]</div>
<p>We now want to use this equation to derive transport equations for the Reynolds stresses and the turbulent kinetic energy. The turbulent kinetic energy is <span class="math notranslate nohighlight">\(k = 0.5 \overline{\boldsymbol{u}' \cdot \boldsymbol{u}'} = 0.5 \overline{u_i'u_i'}\)</span>. An equation for <span class="math notranslate nohighlight">\(k\)</span> can be obtained by multiplying Eq. <a class="reference internal" href="#equation-eq-fluctvelindex">(51)</a> with <span class="math notranslate nohighlight">\(u_i'\)</span> and then taking the average of the resulting equation. However, here we will make the derivation of the Reynolds stress <span class="math notranslate nohighlight">\(\overline{u_i'u_j'}\)</span> first, because then we can get the equation for <span class="math notranslate nohighlight">\(\overline{u_i'u_i'}\)</span> simply by taking the trace of the Reynolds stress equation. Start the derivation by multiplying Eq. <a class="reference internal" href="#equation-eq-fluctvelindex">(51)</a> by <span class="math notranslate nohighlight">\(u_k'\)</span> and then perform an average of the entire resulting equation. For simplicity we neglect the body force <span class="math notranslate nohighlight">\(f_i\)</span></p>
<div class="math notranslate nohighlight">
\[ \overline{  u_k'\left( \frac{\partial u_i'}{\partial t} + \overline{u}_j \frac{\partial u_i'}{\partial x_j} = -\frac{1}{\rho}\frac{\partial p'}{\partial x_i} + \nu \frac{\partial^2 u_i'}{\partial x_j \partial x_j} - u_j'\frac{\partial \overline{u}_i}{\partial x_j} - u_j'\frac{\partial u_i'}{\partial x_j} +\frac{\partial \overline{u_i' u_j'}}{\partial x_j} \right) }.\]</div>
<p>Most terms are trivially manipulated, and the last term on the rhs disappears</p>
<div class="math notranslate nohighlight">
\[\overline{  u_k' \frac{\partial u_i'}{\partial t}} + \overline{u}_j \overline{u_k'\frac{\partial u_i'}{\partial x_j}} = -\frac{1}{\rho}\overline{u_k'\frac{\partial p'}{\partial x_i}} + \nu \overline{u_k'\frac{\partial^2 u_i'}{\partial x_j \partial x_j}} - \overline{u_k'u_j'}\frac{\partial \overline{u}_i}{\partial x_j} - \overline{u_k' u_j'\frac{\partial u_i'}{\partial x_j}}.\]</div>
<p>Since both <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(i\)</span> are free indices they can be interchanged into another equation</p>
<div class="math notranslate nohighlight">
\[\overline{  u_i' \frac{\partial u_k'}{\partial t}} + \overline{u}_j \overline{u_i'\frac{\partial u_k'}{\partial x_j}} = -\frac{1}{\rho}\overline{u_i'\frac{\partial p'}{\partial x_k}} + \nu \overline{u_i'\frac{\partial^2 u_k'}{\partial x_j \partial x_j}} - \overline{u_i'u_j'}\frac{\partial \overline{u}_k}{\partial x_j} - \overline{u_i' u_j'\frac{\partial u_k'}{\partial x_j}}.\]</div>
<p>Noting that, e.g., <span class="math notranslate nohighlight">\(\partial u_i'u_k'/\partial t=u_i'\partial u_k'/\partial t + u_k'\partial u_i'/\partial t\)</span>, you should now be able to realize that the sum of the two previous equations will give us an equation for <span class="math notranslate nohighlight">\(\overline{u_i'u_k'}\)</span></p>
<div class="math notranslate nohighlight" id="equation-eq-reynoldsstressraw">
<span class="eqno">(52)<a class="headerlink" href="#equation-eq-reynoldsstressraw" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
 \frac{\partial \overline{ u_i'u_k'}}{\partial t} + \overline{u}_j \frac{\partial\overline{ u_i'u_k'}}{\partial x_j} =&amp; -\frac{1}{\rho}\left( \overline{u_i'\frac{\partial p'}{\partial x_k}} + \overline{u_k'\frac{\partial p'}{\partial x_i}} \right) \notag \\
&amp;+ \nu \left( \overline{u_i'\frac{\partial^2 u_k'}{\partial x_j \partial x_j}} + \overline{u_k'\frac{\partial^2 u_i'}{\partial x_j \partial x_j}} \right) \notag\\
&amp;- \overline{u_i'u_j'}\frac{\partial \overline{u}_k}{\partial x_j} -           \overline{u_k'u_j'}\frac{\partial \overline{u}_i}{\partial x_j} \notag \\
&amp;- \overline{u_i' u_j'\frac{\partial u_k'}{\partial x_j}} - \overline{u_k' u_j'\frac{\partial u_i'}{\partial x_j}}.
\end{aligned}\end{split}\]</div>
<p>Several terms on the rhs can be further simplified. Using the product rule the pressure terms can alternatively be written as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 \overline{u_i'\frac{\partial p'}{\partial x_k}} + \overline{u_k'\frac{\partial p'}{\partial x_i}}
&amp;= \overline{p' \left( \frac{\partial u_i'}{\partial x_k} + \frac{\partial u_k'}{\partial x_i} \right)} + \frac{\partial}{\partial x_j}\left( \overline{p' u_i'}\delta_{kj} + \overline{p' u_k'}\delta_{ij} \right), \\
 &amp;= 2 \overline{p' s_{ik}'} + \frac{\partial}{\partial x_j}\left( \overline{p' u_i'}\delta_{kj} + \overline{p' u_k'}\delta_{ij} \right),
\end{aligned}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[s_{ij}' = \frac{1}{2} \left( \frac{\partial u_i'}{\partial x_j} + \frac{\partial u_j'}{\partial x_i}\right)\]</div>
<p>and the notation with the identity tensor is used to enable a divergence form (<span class="math notranslate nohighlight">\(\partial \overline{p'u_i'}/\partial x_k = \partial \overline{p' u_i'} /\partial x_j \delta_{kj}\)</span>). This notation is used to emphasize that the term is conservative, it can neither create nor destroy <span class="math notranslate nohighlight">\(\overline{u_i' u_k'}\)</span>, but simply serves to move it around. For this reason the term is often referred to as pressure diffusion.</p>
<p>The two  Laplacian terms in Eq. <a class="reference internal" href="#equation-eq-reynoldsstressraw">(52)</a> can be simplified using the following identities</p>
<div class="math notranslate nohighlight">
\[ u_i'\frac{\partial^2 u_k'}{\partial x_j \partial x_j} = \frac{\partial}{\partial x_j}\left( \frac{\partial u_i'u_k'}{\partial x_j} - u_k'\frac{\partial u_i'}{\partial x_j} \right) - \frac{\partial u_i'}{\partial x_j} \frac{\partial u_k'}{\partial x_j}\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[ u_k'\frac{\partial^2 u_i'}{\partial x_j \partial x_j} = \frac{\partial}{\partial x_j}\left( u_k' \frac{\partial u_i'}{\partial x_j} \right) - \frac{\partial u_i'}{\partial x_j} \frac{\partial u_k'}{\partial x_j}.\]</div>
<p>Summing up these two equations we get</p>
<div class="math notranslate nohighlight">
\[u_i'\frac{\partial^2 u_k'}{\partial x_j \partial x_j} + u_k'\frac{\partial^2 u_i'}{\partial x_j \partial x_j} = \frac{\partial^2 u_i'u_k'}{\partial x_j \partial x_j} - 2 \frac{\partial u_i'}{\partial x_j} \frac{\partial u_k'}{\partial x_j}.\]</div>
<p>Finally, note that due to continuity</p>
<div class="math notranslate nohighlight">
\[  u_i' u_j' \frac{\partial u_k'}{\partial x_j} +  u_k' u_j' \frac{\partial u_i'}{\partial x_j} = \frac{\partial u_i' u_k' u_j'}{\partial x_j}.\]</div>
<p>Inserting for all the simplifications above we obtain a final form for the Reynolds stress transport equation</p>
<div class="math notranslate nohighlight" id="equation-eq-reynoldsstress">
<span class="eqno">(53)<a class="headerlink" href="#equation-eq-reynoldsstress" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial \overline{ u_i'u_k'}}{\partial t} + \overline{u}_j \frac{\partial\overline{ u_i'u_k'}}{\partial x_j} =&amp; -\frac{2\overline{p' s_{ik}'}}{\rho} - \frac{\partial}{\partial x_j}\left( \frac{1}{\rho}(\overline{p' u_i'}\delta_{kj} + \overline{p' u_k'}\delta_{ij}) + \overline{u_i'u_k'u_j'} - \nu \frac{\partial \overline{u_i'u_k'}}{\partial x_j} \right) \notag \\
&amp;- 2 \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_k'}{\partial x_j}} - \overline{u_i'u_j'}\frac{\partial \overline{u}_k}{\partial x_j} -           \overline{u_k'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>This is the same as Eq.~(6-18) in <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>. Note that  on the right hand side only the last two terms on the bottom line and the last on the first line are closed since they only contain <span class="math notranslate nohighlight">\(\overline{u_i'u_k'}\)</span> and gradients of the mean velocity. This means that in our ambitious effort to find a closure for <span class="math notranslate nohighlight">\(\overline{u_i'u_k'}\)</span> from first principles we have ended up creating even more problems for our self.</p>
<p>An equation for the turbulent kinetic energy <span class="math notranslate nohighlight">\(k\)</span> can be obtained by contracting the two free indices in Eq. <a class="reference internal" href="#equation-eq-reynoldsstress">(53)</a> (set index <span class="math notranslate nohighlight">\(k=i\)</span>). A few terms disappear due to continuity (<span class="math notranslate nohighlight">\(s_{ii}'=0\)</span>) and symmetry leading to</p>
<div class="math notranslate nohighlight" id="equation-eq-uiuifirst">
<span class="eqno">(54)<a class="headerlink" href="#equation-eq-uiuifirst" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial \overline{ u_i'u_i'}}{\partial t} + \overline{u}_j \frac{\partial\overline{ u_i'u_i'}}{\partial x_j} =&amp; - \frac{\partial}{\partial x_j}\left( \frac{2}{\rho}\overline{p' u_i'}\delta_{ij}  + \overline{u_i'u_i'u_j'} - \nu \frac{\partial \overline{u_i'u_i'}}{\partial x_j} \right) \notag \\
&amp;- 2 \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_i'}{\partial x_j}} - 2\overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>If we simplify this further using <span class="math notranslate nohighlight">\(k = 0.5 \overline{u_i'u_i'}\)</span> we obtain</p>
<div class="math notranslate nohighlight" id="equation-eq-uiuisecond">
<span class="eqno">(55)<a class="headerlink" href="#equation-eq-uiuisecond" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial k}{\partial t} + \overline{u}_j \frac{\partial k}{\partial x_j} =&amp; - \frac{\partial}{\partial x_j}\left( \frac{1}{\rho}\overline{p' u_i'}\delta_{ij}  + \frac{1}{2}\overline{u_i'u_i'u_j'} - \nu \frac{\partial k}{\partial x_j} \right) \notag \\
&amp;- \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_i'}{\partial x_j}} - \overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>Evidently this equation differs in a few places from Eq.~(6-17) in \cite{white06}. However, the difference is merely due to a few rearrangements and we will now derive also a slightly different form more similar to (6-17). Note that the Laplacian term, i.e., the last of the divergence terms on the rhs of Eq. <a class="reference internal" href="#equation-eq-uiuifirst">(54)</a>, can alternatively be rewritten using the identity</p>
<div class="math notranslate nohighlight">
\[ \nu \frac{\partial^2 u_i' u_i' }{\partial x_j \partial x_j} = 4\nu \frac{\partial s_{ij}'u_i'}{\partial x_j} - 2 \nu \frac{\partial u_i'}{\partial x_j} \frac{\partial u_j'}{\partial x_i}.\]</div>
<p>Inserting this into Eq. <a class="reference internal" href="#equation-eq-uiuifirst">(54)</a> leads to</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\frac{\partial k}{\partial t} + \overline{u}_j \frac{\partial k}{\partial x_j} =&amp; - \frac{\partial}{\partial x_j}\left( \frac{1}{\rho}\overline{p' u_i'}\delta_{ij}  + \frac{1}{2}\overline{u_i'u_i'u_j'} - 2\nu  \overline{s_{ij}'u_i'} \right) \\
&amp;- 2\nu \overline{\frac{\partial u_i'}{\partial x_j} s_{ij}'} - \overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>Furthermore, the velocity deformation tensor can be decomposed as</p>
<div class="math notranslate nohighlight">
\[  \frac{\partial u_i'}{\partial x_j} = s_{ij}' + \omega_{ij}',\]</div>
<p>where the anti-symmetric rotation rate tensor <span class="math notranslate nohighlight">\(\omega_{ij}'\)</span> is given as</p>
<div class="math notranslate nohighlight">
\[ \omega_{ij}' = \frac{1}{2} \left( \frac{\partial u_i'}{\partial x_j} -  \frac{\partial u_j'}{\partial x_i} \right).\]</div>
<p>Since the contraction of a symmetric tensor with an anti-symmetric is identically zero it follows that</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  s_{ij}' \frac{\partial u_i'}{\partial x_j} &amp;= s_{ij}'s_{ij}' + s_{ij}'\omega_{ij}' \\
  &amp;= s_{ij}'s_{ij}'.
\end{aligned}\end{split}\]</div>
<p>The final form of the turbulent kinetic energy equation, which is also the one that is most often used in the literature, is thus</p>
<div class="math notranslate nohighlight" id="equation-eq-kineticenergyeq">
<span class="eqno">(56)<a class="headerlink" href="#equation-eq-kineticenergyeq" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial k}{\partial t} + \overline{u}_j \frac{\partial k}{\partial x_j} =&amp; - \frac{\partial}{\partial x_j}\left( \frac{1}{\rho}\overline{p' u_i'}\delta_{ij}  + \frac{1}{2}\overline{u_i'u_i'u_j'} - 2\nu  \overline{s_{ij}'u_i'} \right) \notag \\
&amp;- 2\nu \overline{s_{ij}' s_{ij}'} - \overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}.
\end{aligned}\end{split}\]</div>
<p>All terms in the turbulent kinetic energy equation have their own physical interpretation</p>
<ul>
<li><p>Rate of change of <span class="math notranslate nohighlight">\(k\)</span> due to non-stationary statistics</p>
<div class="math notranslate nohighlight">
\[
  \frac{\partial k}{\partial t}
   \]</div>
</li>
<li><p>Rate of change of <span class="math notranslate nohighlight">\(k\)</span> due to convection</p>
<div class="math notranslate nohighlight">
\[
  \overline{u}_j \frac{\partial k}{\partial x_j}
   \]</div>
</li>
<li><p>Conservative transport of kinetic energy in an inhomogeneous field due respectively to the pressure fluctuations, the turbulence itself, and the viscous stresses:</p>
<div class="math notranslate nohighlight">
\[
  \frac{\partial}{\partial x_j}\left( \frac{1}{\rho}\overline{p' u_i'}\delta_{ij}  + \frac{1}{2}\overline{u_i'u_i'u_j'} - 2\nu  \overline{s_{ij}'u_i'} \right)
   \]</div>
</li>
<li><p>Rate of production of turbulence kinetic energy from the mean flow (gradient):</p>
<div class="math notranslate nohighlight">
\[
  \overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}
   \]</div>
</li>
<li><p>Rate of dissipation of turbulence kinetic energy per unit mass due to viscous stresses:</p>
<div class="math notranslate nohighlight">
\[
  \varepsilon = 2\nu \overline{s_{ij}' s_{ij}'}
   \]</div>
</li>
</ul>
</div>
<div class="section" id="turbulence-modelling">
<h3>Turbulence modelling<a class="headerlink" href="#turbulence-modelling" title="Permalink to this headline">Â¶</a></h3>
<p>Turbulence modelling is all about finding suitable closures, or models, for the Reynolds stress tensor. The Reynolds stress tensor is symmetrical</p>
<div class="math notranslate nohighlight">
\[ \overline{u_i'u_j'} = \overline{u_j'u_i'}\]</div>
<p>and thus contains 6 unknown quantities. The Reynolds stress is not really a stress, but it is so called because of the way it appears in the mean momentum equation <a class="reference internal" href="#equation-eq-rans">(48)</a>. The mean momentum equation can alternatively be rewritten as</p>
<div class="math notranslate nohighlight" id="equation-eq-rans2">
<span class="eqno">(57)<a class="headerlink" href="#equation-eq-rans2" title="Permalink to this equation">Â¶</a></span>\[  \rho \left(\frac{\partial \overline{\boldsymbol{u}}}{\partial t} + (\overline{\boldsymbol{u}} \cdot \nabla)\overline{\boldsymbol{u}} \right) = \nabla \cdot \overline{\tau} + \rho\overline{\boldsymbol{f}}, \]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\overline{\tau}_{ij} = -\overline{p}\delta_{ij} + 2 \mu \overline{S}_{ij} - \rho\overline{u_i'u_j'},\]</div>
<p>is a new term that has dimensions of stress and</p>
<div class="math notranslate nohighlight">
\[ \overline{S}_{ij} = \frac{1}{2}\left(\frac{\partial \overline{u}_i}{\partial x_j} + \frac{\partial \overline{u}_j}{\partial x_i} \right).\]</div>
<p>Mathematically then it appears that the total mean stress tensor has been added a third term <span class="math notranslate nohighlight">\(-\rho \overline{u_i'u_j'}\)</span> after the regular pressure and viscous stresses. The term is called a Reynolds âstressâ, but it is in fact just the contribution of the fluctuating velocities to the mean nonlinear convection. (Note that <span class="math notranslate nohighlight">\(\rho\)</span> is required for the term to have dimensions of stress.) By stress we usually mean the internal forces that fluid particles exert on each other.</p>
<p>The highest level of RANS modelling is usually considered the second moment closures that solve transport equations for <span class="math notranslate nohighlight">\(\overline{u_i'u_j'}\)</span> directly. Second moment closures are outside the scope of this course.</p>
<p>The by far most commonly used turbulence model is the eddy viscosity (first moment) closure</p>
<div class="math notranslate nohighlight" id="equation-eq-eddyviscosity">
<span class="eqno">(58)<a class="headerlink" href="#equation-eq-eddyviscosity" title="Permalink to this equation">Â¶</a></span>\[  \overline{u_i'u_j'} = -2\nu_T\overline{S}_{ij} + \frac{2}{3}k\delta_{ij},\]</div>
<p>where <span class="math notranslate nohighlight">\(\nu_T\)</span> is a âturbulent viscosityâ. Turbulence models are usually classified by the number of additional PDEâs that are used to model the turbulent viscosity.</p>
<p>The turbulent viscosity is a parameter of the flow and not the fluid. As mentioned before, one of the most important properties of a turbulent flow is its ability to efficiently mix momentum and scalars, like temperature. Mathematically, the enhanced mixing is manifested through the Reynolds stress and it is through Eq. <a class="reference internal" href="#equation-eq-eddyviscosity">(58)</a> sought modelled as a diffusion process using <span class="math notranslate nohighlight">\(\nu_T\)</span> as a positive (<span class="math notranslate nohighlight">\(\ge0\)</span>) mixing rate constant. Inserted into the momentum equation the eddy viscosity gives rise to the term</p>
<div class="math notranslate nohighlight">
\[  \frac{\partial \overline{u_i'u_j'}}{\partial x_j} = -\frac{\partial }{\partial x_j}\left[ \nu_t \left( \frac{\partial \overline{u}_i}{\partial x_j} + \frac{\partial \overline{u}_j}{\partial x_i} \right) \right] + \frac{2}{3} \frac{\partial k }{\partial x_i},\]</div>
<p>and it can be seen that the first term on the right hand side will lead to enhanced mixing (or diffusion) of <span class="math notranslate nohighlight">\(\overline{u}_i\)</span> as long as <span class="math notranslate nohighlight">\(\nu_T\)</span> is positive.</p>
<p>Having established an algebraic model for the Reynolds stress <a class="reference internal" href="#equation-eq-eddyviscosity">(58)</a>, we have reduced the number of unknowns from 6 to 2 (<span class="math notranslate nohighlight">\(\nu_T\)</span> and <span class="math notranslate nohighlight">\(k\)</span>). We will now discuss the most common strategies for closing the remaining terms.</p>
<p>The turbulent viscosity is by dimensional reasoning the product of a velocityscale <span class="math notranslate nohighlight">\(\tilde{u}\)</span> and a lengthscale <span class="math notranslate nohighlight">\(l\)</span></p>
<div class="math notranslate nohighlight">
\[  \nu_T = \tilde{u} \cdot l,\]</div>
<p>where different interpretations are possible for defining such scales. Remembering that one of the âdefiningâ properties of turbulence is that it contains a range of scales, such a classification into one single velocity- and lengthscale may seem questionable from the very start. Nevertheless, most turbulence models boil down to finding good approximations for these scales, and the modelled scales are then usually interpreted as the largest scales of turbulence. Many different models exist (including multiscale models, which is beside the scope for this course) and sometimes a timescale <span class="math notranslate nohighlight">\(t_k\)</span> is used instead of <span class="math notranslate nohighlight">\(\tilde{u}\)</span>, but then the two are related through <span class="math notranslate nohighlight">\(\tilde{u} = l / t_k\)</span>.</p>
<p>Turbulence models are usually classified by the number of additional PDEs that are required to establish the proper scales and we will now go through some of the most basic models.</p>
<div class="section" id="zero-equation-models">
<h4>Zero-equation models<a class="headerlink" href="#zero-equation-models" title="Permalink to this headline">Â¶</a></h4>
<p>Zero-equation turbulence models are models that use zero additional PDEs to model the turbulent viscosity. The Mixing length model was the first such turbulence model. For a simple plane shear flow where <span class="math notranslate nohighlight">\(\overline{u}\)</span> is the tangential velocity and <span class="math notranslate nohighlight">\(y\)</span> is the wall normal direction the model reads</p>
<div class="math notranslate nohighlight" id="equation-eq-mixinglength">
<span class="eqno">(59)<a class="headerlink" href="#equation-eq-mixinglength" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
 \tilde{u} &amp;= l \left|\frac{\mathrm{d} \overline{u}}{\mathrm{d} y} \right|, \notag \\
 \nu_T &amp;= l^2 \left|\frac{\mathrm{d} \overline{u}}{\mathrm{d} y}\right|.
\end{aligned}\end{split}\]</div>
<p>For a plane shear flow the model is excellent as one may choose</p>
<div class="math notranslate nohighlight" id="equation-eq-mixinglengthl">
<span class="eqno">(60)<a class="headerlink" href="#equation-eq-mixinglengthl" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
  l &amp;\approx y^2, \quad \mathrm{for} \quad y^+ &lt; 5, \notag\\
  l &amp;\approx \kappa y, \quad \mathrm{for} \quad 30 &lt; y^+ &lt; 100, \notag \\
  l &amp;\approx 1, \quad \mathrm{for} \quad y^+ &gt; 100
\end{aligned}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\kappa=0.41\)</span> is von KÃ¡rmÃ¡nâs constant and <span class="math notranslate nohighlight">\(y\)</span> is the distance to the wall. Further</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  v^* &amp;= \sqrt{\nu \frac{\partial \overline{u}}{\partial y}}_{\mathrm{wall}}, \\
  y^+ &amp;= \frac{y v^*}{\nu},
\end{aligned}\end{split}\]</div>
<p>are, respectively, the turbulent wall friction velocity and the distance to the wall in normalized âwallâ units. A Reynolds number based on the friction velocity, <span class="math notranslate nohighlight">\(Re_{\tau}=L\cdot v^*/\nu\)</span>, is often used to characterize flow in turbulent plane shear flows.</p>
<p>Several models exist that merge the three domains in Eq. <a class="reference internal" href="#equation-eq-mixinglengthl">(60)</a> into one single continuous function. Van Driest provided a model that merged the first two inner layers using</p>
<div class="math notranslate nohighlight" id="equation-eq-vandriest">
<span class="eqno">(61)<a class="headerlink" href="#equation-eq-vandriest" title="Permalink to this equation">Â¶</a></span>\[ l = \kappa y \left(1 - \exp\left( -\frac{y^+}{A}\right) \right),\]</div>
<p>where <span class="math notranslate nohighlight">\(A\)</span> is a constant set to 26 for flat plate flow. This model should be merged with <span class="math notranslate nohighlight">\(l=\mathrm{constant}\)</span> far enough from the wall.  Far enough is often chosen when <span class="math notranslate nohighlight">\(l\)</span> from Eq. <a class="reference internal" href="#equation-eq-vandriest">(61)</a> becomes larger than a factor of the mixing layer thickness <span class="math notranslate nohighlight">\(\delta\)</span>. An often used estimate is when <span class="math notranslate nohighlight">\(\kappa y = 0.09\delta\)</span> or <span class="math notranslate nohighlight">\(y = 0.22 \delta\)</span>.</p>
<p>The Mixing length model is not a good model for other flows than plane boundary layer flows. For example, in the center of a plane channel the mean velocity gradient is zero due to symmetry (<span class="math notranslate nohighlight">\(\mathrm{d} \overline{u} / \mathrm{d} y = 0\)</span>). The Mixing length model Eq. <a class="reference internal" href="#equation-eq-mixinglength">(59)</a> thus predicts that the turbulent viscosity should be zero in the center of the channel. This is contrary to the experimental observation and intuition, because the turbulent intensity is actually very large in the center.</p>
<p>This flaws of the mixing length model first led to the suggested improvement that the velocityscale should be proportional to the turbulence intensity and not the mean velocity gradient</p>
<div class="math notranslate nohighlight" id="equation-eq-utilde">
<span class="eqno">(62)<a class="headerlink" href="#equation-eq-utilde" title="Permalink to this equation">Â¶</a></span>\[  \tilde{u} = \mathrm{const} \cdot \sqrt{k}.\]</div>
<p>The problem now is that this model introduces a new unknown <span class="math notranslate nohighlight">\(k\)</span> that requires modelling (whereas the old model used known quantities <span class="math notranslate nohighlight">\(l\)</span> and <span class="math notranslate nohighlight">\(\overline{u}\)</span>). Thus one additional PDE is required for closure of the turbulent viscosity.</p>
</div>
<div class="section" id="one-equation-models">
<h4>One-equation models<a class="headerlink" href="#one-equation-models" title="Permalink to this headline">Â¶</a></h4>
<p>Most one-equation turbulence models solves a transport equation for <span class="math notranslate nohighlight">\(k\)</span>, the turbulent kinetic energy. The equation for <span class="math notranslate nohighlight">\(k\)</span> has already been derived in previous assignments  and it is evident that it contains even more unclosed terms. If we start by rewriting the <span class="math notranslate nohighlight">\(k\)</span>-equation as</p>
<div class="math notranslate nohighlight" id="equation-eq-uiuisecond2">
<span class="eqno">(63)<a class="headerlink" href="#equation-eq-uiuisecond2" title="Permalink to this equation">Â¶</a></span>\[\begin{aligned}
\frac{\partial k}{\partial t} + \overline{u}_j \frac{\partial k}{\partial x_j} =&amp; - \frac{\partial T_j}{\partial x_j} \notag + P - \tilde{\varepsilon}
\end{aligned}\]</div>
<p>then the terms on the right hand side are</p>
<div class="math notranslate nohighlight" id="equation-eq-oneequation">
<span class="eqno">(64)<a class="headerlink" href="#equation-eq-oneequation" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
T_j &amp;= \frac{1}{\rho}\overline{p' u_i'}\delta_{ij}  + \frac{1}{2}\overline{u_i'u_i'u_j'} - \nu \frac{\partial k}{\partial x_j}, \\
P &amp;= -\overline{u_i'u_j'}\frac{\partial \overline{u}_i}{\partial x_j}, \\
\tilde{\varepsilon} &amp;= \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_i'}{\partial x_j}} .
\end{aligned}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(T_j\)</span> represents turbulent transport, <span class="math notranslate nohighlight">\(P\)</span> is production of turbulent kinetic energy and <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> is âpseudoâ-dissipation of turbulent kinetic energy. The production <span class="math notranslate nohighlight">\(P\)</span> is closed since it only contains known quantities like the Reynolds stress and mean velocity gradients. The first two terms of <span class="math notranslate nohighlight">\(T_j\)</span> and <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> are unknown and require closure.  <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> is called âpseudoâ-dissipation since the actual dissipation of <span class="math notranslate nohighlight">\(k\)</span> is really <span class="math notranslate nohighlight">\(2\nu\overline{s_{ij}' s_{ij}'}\)</span>. The two terms are related through the identity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
 2\nu\overline{s_{ij}' s_{ij}'} &amp;= \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_i'}{\partial x_j}} + \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_j'}{\partial x_i}}, \\
 \varepsilon &amp;= \tilde{\varepsilon} + \nu \overline{\frac{\partial u_i'}{\partial x_j} \frac{\partial u_j'}{\partial x_i}}.
\end{aligned}\end{split}\]</div>
<p>Since the last term on the rhs is small relative to the first, dissipation and âpseudoâ-dissipation are similar for most flows.</p>
<p>The turbulent transport term is usually modelled as gradient diffusion</p>
<div class="math notranslate nohighlight">
\[  T_j = -\left(\nu + \frac{\nu_t}{\sigma_k} \right) \frac{\partial k}{\partial x_j} ,\]</div>
<p>where <span class="math notranslate nohighlight">\(\sigma_k\)</span> is a constant in the near vicinity of one. Like the name suggests the model enhances diffusion of <span class="math notranslate nohighlight">\(k\)</span> and serves to smooth out the <span class="math notranslate nohighlight">\(k\)</span> field faster than possible simply through regular diffusion. This corresponds well with our knowledge of turbulence as an efficient mixing process.</p>
<p>The âpseudoâ-dissipation rate scales like</p>
<div class="math notranslate nohighlight">
\[ \tilde{\varepsilon} \approx \frac{\tilde{u}^3}{l}.\]</div>
<p>Thus we can find a suitable model for <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> simply by inserting for Eq. <a class="reference internal" href="#equation-eq-utilde">(62)</a></p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \tilde{\varepsilon} &amp;= \frac{(\mathrm{const} \cdot \sqrt{k})^3}{l}, \\
  \tilde{\varepsilon} &amp;= \mathrm{const} \cdot \frac{k^{3/2}}{l}, \\
\end{aligned}\end{split}\]</div>
<p>and thus</p>
<div class="math notranslate nohighlight">
\[\begin{split}  l = \mathrm{const} \cdot \frac{k^{3/2}}{\tilde{\varepsilon}}. \\\end{split}\]</div>
<p>By inserting for the velocity- and lengthscales we get the following model for the  turbulent viscosity</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
  \nu_T &amp;= \mathrm{const} \cdot \sqrt{k} l, \\
  \nu_T &amp;= \mathrm{const} \cdot \frac{k^2}{\tilde{\varepsilon}}.
\end{aligned}\end{split}\]</div>
<p>A weakness of the model is that it requires the lengthscale <span class="math notranslate nohighlight">\(l\)</span> to be provided from knowledge of the problem under consideration. For this reason one-equation turbulence models are often referred to as being incomplete. One-equation models are popular for systems where the mixing length can be easily specified, like a plane boundary layer or an aeroplane wing.</p>
</div>
<div class="section" id="two-equation-models">
<h4>Two-equation models<a class="headerlink" href="#two-equation-models" title="Permalink to this headline">Â¶</a></h4>
<p>Two-equation turbulence models introduce an additional PDE for the missing lengthscale. Since two-equation models do not require any parameter (like <span class="math notranslate nohighlight">\(l\)</span>) from previous knowledge of the system, the two-equation models are often referred to as being complete.</p>
<p>The most popular two-equation turbulence models are variations of the <span class="math notranslate nohighlight">\(k-\tilde{\varepsilon}\)</span> model and the <span class="math notranslate nohighlight">\(k-\omega\)</span> model. <span class="math notranslate nohighlight">\(k-\tilde{\varepsilon}\)</span> models solve one PDE for <span class="math notranslate nohighlight">\(k\)</span> and an additional for <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span>. Likewise, <span class="math notranslate nohighlight">\(k-\omega\)</span> models solve PDEs for <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(\omega\)</span>, where <span class="math notranslate nohighlight">\(\omega\approx \tilde{\varepsilon} / k\)</span>. If <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> are known then</p>
<div class="math notranslate nohighlight">
\[  l = \frac{k^{3/2}}{\tilde{\varepsilon}}, \quad t_k = \frac{k}{\tilde{\varepsilon}}, \quad  \tilde{u} = \frac{l}{t_k} = \sqrt{k}\]</div>
<p>where <span class="math notranslate nohighlight">\(t_k\)</span> is a turbulent timescale. The turbulent viscosity is as before determined by</p>
<div class="math notranslate nohighlight">
\[  \nu_T = \mathrm{const} \cdot \tilde{u} \cdot l = \mathrm{const} \cdot \frac{k^2}{\tilde{\varepsilon}}.\]</div>
<p>A transport equation for <span class="math notranslate nohighlight">\(\tilde{\varepsilon}\)</span> can be derived exactly from the Navier-Stokes equations. The resulting equation contains many new unknowns and here we will not go into detail. Instead we will here simply report the entire and closed <span class="math notranslate nohighlight">\(k-\tilde{\varepsilon}\)</span> model with its most common model âconstantsâ</p>
<div class="math notranslate nohighlight" id="equation-eq-standardkepsilon">
<span class="eqno">(65)<a class="headerlink" href="#equation-eq-standardkepsilon" title="Permalink to this equation">Â¶</a></span>\[\begin{split}\begin{aligned}
\frac{\partial \overline{u}_i}{\partial t} + \overline{u}_j \frac{\partial \overline{u}_i}{\partial x_j} &amp;= \frac{\partial}{\partial x_j}\left[ \left( \nu + \nu_T \right) \left(\frac{\partial \overline{u}_i}{\partial x_j} + \frac{\partial \overline{u}_j}{\partial x_i} \right) \right] - \frac{1}{\rho} \frac{\partial \overline{p} + \frac{2}{3} k}{\partial x_i}, \notag \\
\frac{\partial k}{\partial t} + \overline{u}_j \frac{\partial k}{\partial x_j} &amp;= \frac{\partial}{\partial x_j}\left[ \left( \nu + \frac{\nu_T}{\sigma_k} \right) \frac{\partial k}{\partial x_j} \right] + P - \tilde{\varepsilon}, \notag \\
\frac{\partial \tilde{\varepsilon}}{\partial t} + \overline{u}_j \frac{\partial \tilde{\varepsilon}}{\partial x_j} &amp;= \frac{\partial}{\partial x_j}\left[ \left( \nu + \frac{\nu_T}{\sigma_{\varepsilon}} \right) \frac{\partial \tilde{\varepsilon}}{\partial x_j} \right] + C_{\tilde{\varepsilon}_1} \frac{P \tilde{\varepsilon}}{k} - C_{\tilde{\varepsilon}_2}\frac{\tilde{\varepsilon}^2}{k},
 \\
\frac{\partial \overline{u}_i }{\partial x_i} &amp;= 0, \notag \\
\nu_T &amp;= C_{\mu} \frac{k^2}{\tilde{\varepsilon}}, \notag \\
C_{\mu} = 0.09, \quad C_{\tilde{\varepsilon}_1}&amp;=1.44, \quad C_{\tilde{\varepsilon}_2}=1.92, \quad \sigma_{\tilde{\varepsilon}}=1.3, \quad \sigma_k = 1. \notag
\end{aligned}\end{split}\]</div>
<p>Unfortunately the model âconstantsâ are known to vary from flow to flow and thus often in need of tuning for optimal performance. Nevertheless, two-equation models are complete and the <span class="math notranslate nohighlight">\(k-\tilde{\varepsilon}\)</span> model is very much in use in industry for a wide range of flows.</p>
<p>There is a great number of different RANS turbulence models. Some are listed on the page for NASAâs <a class="reference external" href="http://turbmodels.larc.nasa.gov/">Turbulence Modelling Resources</a> and the <a class="reference external" href="http://www.cfd-online.com/Wiki/Turbulence_modeling">wiki</a> for turbulence modeling.</p>
</div>
<div class="section" id="boundary-conditions">
<h4>Boundary conditions<a class="headerlink" href="#boundary-conditions" title="Permalink to this headline">Â¶</a></h4>
<p>The average statistics in a turbulent flow have sharp gradients in the near vicinity of a wall.  To properly resolve all statistics the location of the first inner computational node needs to be at approximately <span class="math notranslate nohighlight">\(y^+=1\)</span>. This restriction is quite demanding in terms of grid resolution, especially at high Reynolds number. The standard <span class="math notranslate nohighlight">\(k-\tilde{\varepsilon}\)</span> model, Eq. <a class="reference internal" href="#equation-eq-standardkepsilon">(65)</a>, is not very accurate close to walls and many modifications exist to handle this problem. Two main approaches are</p>
<ol class="simple">
<li><p>Do not resolve the flow further than approximately <span class="math notranslate nohighlight">\(y^+=30\)</span> and use wall functions to prescribe boundary conditions inside the wall instead of at the wall.</p></li>
<li><p>Resolve the flow completely (all the way up to <span class="math notranslate nohighlight">\(y^+=1\)</span>) and introduce damping functions.</p></li>
</ol>
<p>The wall functions are based on the log-law</p>
<div class="math notranslate nohighlight">
\[   u^+ = \frac{1}{\kappa} \ln y^+ + B,\]</div>
<p>which is known to be in close agreement with experiments of regular boundary layers for a range of Reynolds numbers. If the first inner node (the first node on the inside of the wall) is located at <span class="math notranslate nohighlight">\(y^p\)</span>, then the velocity can be computed as</p>
<div class="math notranslate nohighlight">
\[  \frac{\overline{u}^p}{u^*} = \frac{1}{\kappa} \ln \frac{y^p u^*}{\nu} + B,\]</div>
<p id="bibtex-bibliography-content/chapter6/turbulence-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets"><a class="fn-backref" href="#id1">Whi06</a></span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-content/solutions/chapter3/intro"></span><div class="section" id="chapter-3">
<h2>Chapter 3<a class="headerlink" href="#chapter-3" title="Permalink to this headline">Â¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-content/solutions/chapter3/couette"></span><div class="section" id="suggested-solutions-couette">
<h3>Suggested solutions Couette<a class="headerlink" href="#suggested-solutions-couette" title="Permalink to this headline">Â¶</a></h3>
<div class="section" id="solutions-written-assignments-couette">
<h4>Solutions written assignments Couette<a class="headerlink" href="#solutions-written-assignments-couette" title="Permalink to this headline">Â¶</a></h4>
<div class="section" id="problem-1">
<h5><a class="reference external" href="../../chapter3/couette.ipynb#problem-3-1">Problem 1</a><a class="headerlink" href="#problem-1" title="Permalink to this headline">Â¶</a></h5>
<p>Solve for a non-Newtonian Couette flow, where the stress tensor is computed as</p>
<div class="math notranslate nohighlight">
\[
  \tau = K\left(\frac{\mathrm{d}u}{\mathrm{d}y}\right)^n,
\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is an integer different from 1.
The momentum equation for any stress tensor in a Couette flow is</p>
<div class="math notranslate nohighlight">
\[
  0 = \nabla \cdot \tau.
\]</div>
<p>For one-dimensional Couette flow aligned with the <span class="math notranslate nohighlight">\(x\)</span>-direction and homogeneous in the <span class="math notranslate nohighlight">\(z\)</span>-direction, the equation reads</p>
<div class="math notranslate nohighlight">
\[
  0 = \frac{\mathrm{d} \tau}{\mathrm{d}y},
\]</div>
<p>which means that <span class="math notranslate nohighlight">\(\tau\)</span> is a constant with respect to <span class="math notranslate nohighlight">\(y\)</span> and thus</p>
<div class="math notranslate nohighlight">
\[
 K\left(\frac{\mathrm{d}u}{\mathrm{d}y}\right)^n = K_2,
\]</div>
<p>where <span class="math notranslate nohighlight">\(K_2\)</span> is a new constant. In other words</p>
<div class="math notranslate nohighlight">
\[
 \frac{\mathrm{d}u}{\mathrm{d}y} = K_3 \left(= (K_2/K)^{1/n}\right),
\]</div>
<p>and thus</p>
<div class="math notranslate nohighlight">
\[
 u = K_3 y + K_4.
\]</div>
<p>The solution is the same as for Newtonian flows regardless of <span class="math notranslate nohighlight">\(n\)</span>.</p>
</div>
</div>
</div>
</div>
</div>
<span id="document-content/solutions/chapter4/intro"></span><div class="section" id="chapter-4">
<h2>Chapter 4<a class="headerlink" href="#chapter-4" title="Permalink to this headline">Â¶</a></h2>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-content/fenics/intro"></span><div class="section" id="fenics">
<h2>FEniCS<a class="headerlink" href="#fenics" title="Permalink to this headline">Â¶</a></h2>
<p><span class="xref myst">FEniCS</span>  is a computing platform for solving partial differential equations (PDEs). FEniCS enables users to quickly translate scientific models into efficient finite element code. With the high-level Python and C++ interfaces to FEniCS, it is easy to get started, but FEniCS offers also powerful capabilities for more experienced programmers. FEniCS runs on a multitude of platforms ranging from laptops to high-performance clusters.</p>
<p>There is an excellent online <a class="reference external" href="https://fenicsproject.org/pub/tutorial/html/ftut1.html">tutorial</a> that is recommended for getting started.</p>
<div class="toctree-wrapper compound">
<span id="document-content/fenics/nonlinear"></span><div class="section" id="numerical-solution-of-nonlinear-equations">
<h3>Numerical solution of nonlinear equations<a class="headerlink" href="#numerical-solution-of-nonlinear-equations" title="Permalink to this headline">Â¶</a></h3>
<p>Several derived equations in <a class="reference external" href="../chapter3/similarity.ipynb#Similarity-solutions">Similarity solutions</a> (e.g., Eq. <a class="reference internal" href="content/intro.html#equation-eq-axistagnationnonnorm">(42)</a>) are nonlinear and no analytical solutions are known. Very few techniques are actually available for solving nonlinear equations analytically and as such we usually have to rely on numerical methods to obtain solutions for real fluid flows. Reynolds Averaged Navier-Stokes equations, that will be discussed thoroughly in chapter 6 of White <a class="bibtex reference internal" href="content/intro.html#white06" id="id1">[Whi06]</a>, are basically Navier-Stokes equations with a nonlinear viscosity coefficient. In this section we will consider two of the most important techniques for iteratively solving nonlinear equations: Picard and Newton iterations.</p>
<p>The general procedure for obtaining solutions to nonlinear equations is to guess an initial solution and then successively recompute new and hopefully better approximations to the solution.  This is illustrated nicely with Newtonâs method (also called Newton-Raphsonâs method). Consider a nonlinear function <span class="math notranslate nohighlight">\(f(x)\)</span> of one variable <span class="math notranslate nohighlight">\(x\)</span> (e.g., <span class="math notranslate nohighlight">\(f(x)=x^2-1\)</span> or <span class="math notranslate nohighlight">\(f(x)=x \sin(x)-1\)</span>), where one is interested in finding the roots <span class="math notranslate nohighlight">\(x\)</span> such that <span class="math notranslate nohighlight">\(f(x)=0\)</span>. Newtonâs method boils down to making an initial guess <span class="math notranslate nohighlight">\(x_0\)</span> that does not satisfy our equation (i.e., <span class="math notranslate nohighlight">\(f(x_0) \neq 0\)</span>) and from this initial guess we successively compute better approximations to the final root:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
\mathrm{Guess }&amp;\, x_0, \quad n=0 \\
\mathrm{while}\,&amp;\,\mathrm{not }\, f(x_n) \approx 0\,\, \mathrm{do} \\
&amp;x_{n+1} = x_{n} - \frac{f(x_{n})}{f'(x_{n})} \\
&amp;n = n + 1
\end{aligned}\end{split}\]</div>
<p>That is, compute <span class="math notranslate nohighlight">\(x_1\)</span> from <span class="math notranslate nohighlight">\(x_0\)</span> and check if the solution is close enough to the root. If not, compute <span class="math notranslate nohighlight">\(x_2\)</span> using <span class="math notranslate nohighlight">\(x_1\)</span> as initial condition. Repeat until <span class="math notranslate nohighlight">\(f(x_n)\approx 0\)</span>.</p>
<p>When PDEs are solved numerically we obtain through discretization a system of many equations for many variables. Newtonâs method extends easily to systems of equations as well. Consider 2 equations with two unknowns written compactly as <span class="math notranslate nohighlight">\(F(\overline{x})\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}  F(\overline{x}) =
  \begin{cases}
  x^2 + 2 x y &amp;= 0, \\
  x + 4 y^2  &amp;= 0,
\end{cases}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\overline{x} = (x, y)^T\)</span>. The vector <span class="math notranslate nohighlight">\(F\)</span> has two components (the two equations) and there are two unknowns. We can compute the derivative of <span class="math notranslate nohighlight">\(F\)</span> with respect to <span class="math notranslate nohighlight">\(\overline{x}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split}  J_{ij} = \frac{\partial F_i}{\partial x_j} =
  \begin{pmatrix}
   2x + 2y &amp; 2 x \\
   1 &amp; 8y
  \end{pmatrix}.\end{split}\]</div>
<p>The derivative is often called the Jacobian. Newtonâs method for these two equations (or any system of equations) is simply</p>
<div class="math notranslate nohighlight">
\[  J(\overline{x}^{k}) (\overline{x}^{k+1} - \overline{x}^{k}) = - F(\overline{x}^{k}),\]</div>
<p>or with index notation for equation <span class="math notranslate nohighlight">\(i\)</span></p>
<div class="math notranslate nohighlight">
\[  J_{ij}^k (x_j^{k+1} - x_j^{k}) = - F_i^k,\]</div>
<p>where the <span class="math notranslate nohighlight">\(k\)</span> index signals that both <span class="math notranslate nohighlight">\(J\)</span> and <span class="math notranslate nohighlight">\(F\)</span> are computed using the solution at iteration step <span class="math notranslate nohighlight">\(k\)</span>. There is no summation on repeated <span class="math notranslate nohighlight">\(k\)</span>âs.</p>
<p>A discrete finite element solution of the function <span class="math notranslate nohighlight">\(u\)</span> can be written as</p>
<div class="math notranslate nohighlight">
\[  u(x) = \sum_{i=0}^{N} u_i v_i(x),\]</div>
<p>where <span class="math notranslate nohighlight">\(v_i\)</span> are the testfunctions. The solution has <span class="math notranslate nohighlight">\(N+1\)</span> unknowns <span class="math notranslate nohighlight">\(u_i\)</span>, or âdegrees of freedomâ, that for a linear Lagrange element are the values at the vertices of the mesh. When a PDE containing both trial- and testfunctions is assembled in FEniCS a set of <span class="math notranslate nohighlight">\(N+1\)</span> linear equations arise for these unknowns. We will now see how nonlinear equations can be handled by FEniCS.</p>
<div class="section" id="nonlinear-poisson-equation">
<h4>Nonlinear Poisson equation<a class="headerlink" href="#nonlinear-poisson-equation" title="Permalink to this headline">Â¶</a></h4>
<p>Consider the nonlinear Poisson equation</p>
<div class="math notranslate nohighlight">
\[  - \nabla \cdot \left(q(u) \nabla u \right) = f(u),\]</div>
<p>where <span class="math notranslate nohighlight">\(q\)</span> and <span class="math notranslate nohighlight">\(f\)</span> may be nonlinear functions of <span class="math notranslate nohighlight">\(u\)</span>. Using testfunction <span class="math notranslate nohighlight">\(v\)</span> and neglecting the boundary term the variational form reads</p>
<div class="math notranslate nohighlight" id="equation-eq-nonlinpoissonvar">
<span class="eqno">(66)<a class="headerlink" href="#equation-eq-nonlinpoissonvar" title="Permalink to this equation">Â¶</a></span>\[  \int_{\Omega}  q(u) \nabla u \cdot \nabla v \mathrm{d}x = \int_{\Omega} f(u) v \mathrm{d}x.\]</div>
<p>This is a nonlinear variational form and we need to solve it iteratively.</p>
<div class="section" id="newton-s-method">
<h5>Newtonâs method<a class="headerlink" href="#newton-s-method" title="Permalink to this headline">Â¶</a></h5>
<p>Consider first Newtonâs method for solving the nonlinear Poisson equation. We use the notation <span class="math notranslate nohighlight">\(u^k\)</span> for the known solution at iteration step <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(u\)</span> the unknown trialfunction. For Newtonâs method we write the variational form solely in terms of known functions</p>
<div class="math notranslate nohighlight">
\[F(u^k;v) =   \int_{\Omega}  q(u^k) \nabla u^k \cdot \nabla v \mathrm{d}x - \int_{\Omega} f(u^k) v \mathrm{d}x.\]</div>
<p><span class="math notranslate nohighlight">\(F(u^k;v)\)</span> is a linear form in that it does not contain the unknown <span class="math notranslate nohighlight">\(u\)</span>, only the testfunction <span class="math notranslate nohighlight">\(v\)</span>. It is a <em>nonlinear</em> form in terms of the known <code class="docutils literal notranslate"><span class="pre">Function</span></code> <span class="math notranslate nohighlight">\(u^k\)</span> though. The Jacobian of  <span class="math notranslate nohighlight">\(F(u^k;v)\)</span> is computed is FEniCS as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>
</div>
<p>A complete implementation that solves the nonlinear Poisson equation on the unit interval x=[0, 1] is shown below, where the use of this <code class="docutils literal notranslate"><span class="pre">J</span></code> should be obvious</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dolfin</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">mesh</span> <span class="o">=</span> <span class="n">UnitIntervalMesh</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">FunctionSpace</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="s1">&#39;CG&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

<span class="n">bc0</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="s2">&quot;std::abs(x[0]) &lt; 1e-10&quot;</span><span class="p">)</span>
<span class="n">bc1</span> <span class="o">=</span> <span class="n">DirichletBC</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;std::abs(x[0]-1) &lt; 1e-10&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">q</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">+</span><span class="n">u</span><span class="o">**</span><span class="mi">4</span>
    
<span class="n">u_</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;x[0]&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u_</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="c1">##solve(F == 0, u_, [bc0, bc1])</span>

<span class="n">J</span> <span class="o">=</span> <span class="n">derivative</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
<span class="n">du</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="ow">and</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">assemble</span><span class="p">(</span><span class="o">-</span><span class="n">F</span><span class="p">)</span>
    <span class="p">[</span><span class="n">bc</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">u_</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span> <span class="k">for</span> <span class="n">bc</span> <span class="ow">in</span> <span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">]]</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">(),</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">u_</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span><span class="o">.</span><span class="n">axpy</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">du</span><span class="o">.</span><span class="n">vector</span><span class="p">())</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>    
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">{}</span><span class="s2"> Error = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Iteration 1 Error = 0.20207598526678652
Iteration 2 Error = 0.006786044472018965
Iteration 3 Error = 1.626130021884984e-05
Iteration 4 Error = 1.1905550866645789e-10
Iteration 5 Error = 8.698631493053902e-17
</pre></div>
</div>
</div>
</div>
<p>Note that everything below the line with <code class="docutils literal notranslate"><span class="pre">solve(F</span> <span class="pre">==</span> <span class="pre">0,</span> <span class="pre">u_,</span> <span class="pre">[bc0,</span> <span class="pre">bc1])</span></code> actually can be replaced simply by using this very compact call. The part from <code class="docutils literal notranslate"><span class="pre">J</span> <span class="pre">=</span> <span class="pre">derivative(F,</span> <span class="pre">u_,</span> <span class="pre">u)</span></code> and out is included here simply to illustrate how Newtonâs method works in practise.</p>
</div>
<div class="section" id="picard-iterations">
<h5>Picard iterations<a class="headerlink" href="#picard-iterations" title="Permalink to this headline">Â¶</a></h5>
<p>For Picard iterations we have to linearize the variational form in Eq. <a class="reference internal" href="#equation-eq-nonlinpoissonvar">(66)</a> ourself. Let us first linearize such that the coefficient is known:</p>
<div class="math notranslate nohighlight">
\[F(u;v) =   \int_{\Omega}  q(u^k) \nabla u \cdot \nabla v \mathrm{d}x - \int_{\Omega} f(u^k, u) v \mathrm{d}x\]</div>
<p>The first term on the rhs of <span class="math notranslate nohighlight">\(F(u;v)\)</span> is bilinear in that it contains both trial- and testfunctions <span class="math notranslate nohighlight">\(u\)</span> and <span class="math notranslate nohighlight">\(v\)</span>. The equation is also linear in <span class="math notranslate nohighlight">\(u\)</span>, which is necessary for FEniCS to accept it. Note that the function <span class="math notranslate nohighlight">\(f\)</span> could be linear in <span class="math notranslate nohighlight">\(u\)</span> as well. For example, if <span class="math notranslate nohighlight">\(f(u) = u^2\)</span>, then we can linearize it like <span class="math notranslate nohighlight">\(f(u) = u \cdot u^k\)</span>. Picard iterations are implemented as Newton up to the point where the form is created. The remaining part of the Picard code reads:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u_</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">Expression</span><span class="p">(</span><span class="s2">&quot;x[0]&quot;</span><span class="p">,</span> <span class="n">degree</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">V</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">q</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span><span class="o">*</span><span class="n">grad</span><span class="p">(</span><span class="n">u</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">error</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="ow">and</span> <span class="n">error</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">F</span> <span class="o">==</span> <span class="n">Constant</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="n">dx</span><span class="p">,</span> <span class="n">u_</span><span class="p">,</span> <span class="p">[</span><span class="n">bc0</span><span class="p">,</span> <span class="n">bc1</span><span class="p">])</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">errornorm</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">u_1</span><span class="p">)</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">u_</span><span class="p">)</span>
    <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iteration </span><span class="si">{}</span><span class="s2"> Error = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">,</span>  <span class="n">error</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-none notranslate"><div class="highlight"><pre><span></span>Iteration 1 Error = 0.6227202551171986
Iteration 2 Error = 0.009279110924024897
Iteration 3 Error = 0.0009571365383617912
Iteration 4 Error = 7.170672306756823e-05
Iteration 5 Error = 1.6196475252925717e-05
Iteration 6 Error = 1.6051762319950847e-06
Iteration 7 Error = 1.5867106937166712e-07
Iteration 8 Error = 3.2011735458409474e-08
Iteration 9 Error = 2.6184233711820267e-09
Iteration 10 Error = 3.617146938878996e-10
Iteration 11 Error = 6.066104630273271e-11
Iteration 12 Error = 4.281972850229132e-12
Iteration 13 Error = 8.043617961021526e-13
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> <code class="docutils literal notranslate"><span class="pre">u_1</span></code> holds the previous solution and <code class="docutils literal notranslate"><span class="pre">u_1.assign(u_)</span></code> copies all values from the newly computed <code class="docutils literal notranslate"><span class="pre">u_</span></code> to <code class="docutils literal notranslate"><span class="pre">u_1</span></code>.</p>
<p>Note that the Newtonâs method requires 5 iterations to converge, whereas Picard requires 13. This is quite typical. Newtonâs method is known to be very efficient when it actually finds the solution, but it often diverges if the initial guess is not close enough to the final solution.  Picard is known to approach the solution more slowly, but in return it is usually more robust in that it finds the solution from a broader range of initial conditions.</p>
<p id="bibtex-bibliography-content/fenics/nonlinear-0"><dl class="citation">
<dt class="bibtex label" id="white06"><span class="brackets"><a class="fn-backref" href="#id1">Whi06</a></span></dt>
<dd><p>FrankÂ M. White. <em>Viscous Fluid Flow</em>. McGraw-Hill, third edition, 2006.</p>
</dd>
</dl>
</p>
</div>
</div>
</div>
<span id="document-content/fenics/transient"></span><div class="section" id="transient-problems">
<h3>Transient problems<a class="headerlink" href="#transient-problems" title="Permalink to this headline">Â¶</a></h3>
<p>Transient problems are usually solved in FEniCS using a finite difference approximation of the time derivative. The time dimension can be discretized using constant discrete time intervals of length <span class="math notranslate nohighlight">\(\triangle t\)</span>, and we look for solutions at the discrete times <span class="math notranslate nohighlight">\(t = [0, \triangle t, 2\triangle t, ..., T-\triangle t, T] = k \triangle t\)</span>, for <span class="math notranslate nohighlight">\(k=0, 1, 2, ..., N-1, N\)</span>, <span class="math notranslate nohighlight">\(\triangle t = T/N\)</span>. The solutions at the <span class="math notranslate nohighlight">\(N+1\)</span> different timesteps are similarly written as <span class="math notranslate nohighlight">\(u^k\)</span>. Using finite differences for the time derivative, a variational form of the heat equation reads</p>
<div class="math notranslate nohighlight">
\[  \int_{\Omega} \frac{u^k - u^{k-1}}{\triangle t} v \mathrm{d}x = -\nu \int_{\Omega} \nabla u^{k-\frac{1}{2}} \cdot \nabla v \mathrm{d}x,\]</div>
<p>where the right hand side is computed at the midpoint between timesteps <span class="math notranslate nohighlight">\(k\)</span> and <span class="math notranslate nohighlight">\(k-1\)</span> using notation <span class="math notranslate nohighlight">\(u^{k - \frac{1}{2}} = (u^k + u^{k-1})/2\)</span>. Note that when the solution is computed, we start at the initial condition at <span class="math notranslate nohighlight">\(k=0\)</span>, where the initial condition <span class="math notranslate nohighlight">\(u^{0}\)</span> is known and <span class="math notranslate nohighlight">\(u^1\)</span> is unknown. When <span class="math notranslate nohighlight">\(u^1\)</span> is subsequently computed and known, we are ready to move on to the next solution <span class="math notranslate nohighlight">\(u^2\)</span> and so on. In other words, <span class="math notranslate nohighlight">\(u^k\)</span> is always the unknown we are trying to compute and <span class="math notranslate nohighlight">\(u^{k-1}, u^{k-2}, ...\)</span> are all considered to be known. In FEniCS the unknown <span class="math notranslate nohighlight">\(u^k\)</span> is represented in <code class="docutils literal notranslate"><span class="pre">Form</span></code>s as a <code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code>, whereas all knowns are represented as <code class="docutils literal notranslate"><span class="pre">Function</span></code>s. A variational form for the heat equation in FEniCS may look like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">TrialFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">TestFunction</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
<span class="n">u_</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>    <span class="c1"># Known solution at k</span>
<span class="n">u_1</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>   <span class="c1"># Known solution at k-1</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">Constant</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">nu</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">U</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">u</span><span class="o">+</span><span class="n">u_1</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">inner</span><span class="p">(</span><span class="n">u</span> <span class="o">-</span> <span class="n">u_1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">nu</span><span class="o">*</span><span class="n">inner</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">U</span><span class="p">),</span> <span class="n">grad</span><span class="p">(</span><span class="n">v</span><span class="p">))</span><span class="o">*</span><span class="n">dx</span>
</pre></div>
</div>
<p>The solution of the form must be placed inside a loop, advancing the solution forward in time, something like:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
    <span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>
    <span class="n">solve</span><span class="p">(</span><span class="n">lhs</span><span class="p">(</span><span class="n">F</span><span class="p">)</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">(</span><span class="n">F</span><span class="p">),</span> <span class="n">u_</span><span class="p">,</span> <span class="n">bcs</span><span class="p">)</span>
    <span class="c1"># Advance solution to next timestep:</span>
    <span class="n">u_1</span><span class="o">.</span><span class="n">vector</span><span class="p">()[:]</span> <span class="o">=</span> <span class="n">u_</span><span class="o">.</span><span class="n">vector</span><span class="p">()</span>
</pre></div>
</div>
<p>The python functions <code class="docutils literal notranslate"><span class="pre">lhs</span></code> and <code class="docutils literal notranslate"><span class="pre">rhs</span></code> are used to extract bilinear (terms containing both trial- and testfunctions) and linear (terms containing only testfunction and no trialfunction) forms respectively. The last line of code copies all the values from <code class="docutils literal notranslate"><span class="pre">u_</span></code> to <code class="docutils literal notranslate"><span class="pre">u_1</span></code>. Note that <span class="math notranslate nohighlight">\(u^k\)</span> is the unknown we look for at timestep <span class="math notranslate nohighlight">\(k\)</span>. In the variational form <span class="math notranslate nohighlight">\(u^k\)</span> is represented as an unknown <code class="docutils literal notranslate"><span class="pre">TrialFunction</span></code>. However, when the variational form has been solved, the known solution can be found in the <code class="docutils literal notranslate"><span class="pre">Function</span></code> <code class="docutils literal notranslate"><span class="pre">u_</span></code> and we are then finished with timestep <span class="math notranslate nohighlight">\(k\)</span>. When we now move on to the next timestep, the solution we just found becomes the solution at the previous timestep, i.e., at <span class="math notranslate nohighlight">\(k-1\)</span>. This is why we copy all values from <code class="docutils literal notranslate"><span class="pre">u_</span></code> to <code class="docutils literal notranslate"><span class="pre">u_1</span></code> as our final task in the time loop.</p>
</div>
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "mikaem/MEK4300",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./content"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Mikael Mortensen<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>